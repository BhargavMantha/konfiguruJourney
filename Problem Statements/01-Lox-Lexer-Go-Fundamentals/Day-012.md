# Day 012: Identifier Scanning

**Month 1:** Lox Lexer & Go Fundamentals
**Phase:** Foundation
**Week:** 2 of 4 - Literals & Advanced Scanning

---

## üéØ Today's Goal

Implement identifier scanning in the Lox lexer. By the end of today, your lexer will recognize variable names, function names, and other identifiers following Lox's naming rules.

**What You'll Build:** Identifier scanning with alphanumeric and underscore support.

---

## üìö What You'll Learn Today

**Go Fundamentals:**
- Character classification (letters vs digits)
- ASCII ranges for uppercase and lowercase
- Multi-condition boolean logic

**Compiler Concepts:**
- Identifier vs keyword distinction
- Alphanumeric scanning
- Underscore handling in names

---

## ‚úÖ Today's Tasks

### Task 1: Review Identifier Rules (20 minutes)

**Lox identifier rules:**

1. **Must start with:**
   - Letter (a-z, A-Z)
   - Underscore (`_`)

2. **Can contain:**
   - Letters (a-z, A-Z)
   - Digits (0-9)
   - Underscores (`_`)

3. **Examples:**
   - Valid: `name`, `count1`, `_temp`, `myVariable`, `CamelCase`
   - Invalid: `1var` (starts with digit), `my-var` (contains hyphen)

**Note:** Keywords are checked AFTER scanning as identifiers.

**Resources:**
- [Crafting Interpreters - Identifiers](https://craftinginterpreters.com/scanning.html#identifiers-and-keywords)

---

### Task 2: Implement isAlpha() and isAlphaNumeric() Helpers (30 minutes)

**What to do:**
Add helper functions for character classification.

**Open scanner.go and add these functions:**

```go
// isAlpha checks if a character is a letter or underscore
func isAlpha(c byte) bool {
	return (c >= 'a' && c <= 'z') ||
		(c >= 'A' && c <= 'Z') ||
		c == '_'
}

// isAlphaNumeric checks if a character is alphanumeric or underscore
func isAlphaNumeric(c byte) bool {
	return isAlpha(c) || isDigit(c)
}
```

**Understanding the code:**
- `isAlpha()` checks three conditions:
  - Lowercase letter: `c >= 'a' && c <= 'z'`
  - Uppercase letter: `c >= 'A' && c <= 'Z'`
  - Underscore: `c == '_'`
- `isAlphaNumeric()` combines `isAlpha()` and `isDigit()`
- Used for identifier scanning

**Verify:**
```bash
go build ./pkg/lexer
```

---

### Task 3: Implement scanIdentifier() Method (35 minutes)

**What to do:**
Add the `scanIdentifier()` method to scan identifier tokens.

**Add to scanner.go:**

```go
// scanIdentifier scans an identifier or keyword
func (s *Scanner) scanIdentifier() {
	// Consume all alphanumeric characters
	for isAlphaNumeric(s.peek()) {
		s.advance()
	}

	// Get the identifier text
	text := s.source[s.start:s.current]

	// Check if it's a keyword, otherwise it's an identifier
	tokenType := tokens.LookupIdent(text)

	s.addToken(tokenType)
}
```

**Key points:**
- Start: already consumed first character (letter or `_`)
- Loop: consume remaining alphanumeric characters
- Extract text: `s.source[s.start:s.current]`
- Lookup: use `tokens.LookupIdent(text)` to check if keyword
- Returns: keyword token type OR IDENTIFIER

**Example walkthrough:**
```
Source: "var myVariable = 42;"
         ^
      start=0

scanToken sees 'v':
- isAlpha('v') ‚Üí true
- Calls scanIdentifier()
- Consumes: "var"
- LookupIdent("var") ‚Üí VAR (keyword)
- Adds VAR token

Later, scanToken sees 'm':
- isAlpha('m') ‚Üí true
- Calls scanIdentifier()
- Consumes: "myVariable"
- LookupIdent("myVariable") ‚Üí IDENTIFIER (not a keyword)
- Adds IDENTIFIER token
```

**Update scanToken() default case:**

Find the `default` case and update it:

```go
	default:
		if isDigit(c) {
			s.scanNumber()
		} else if isAlpha(c) {
			s.scanIdentifier()
		} else {
			s.addError("Unexpected character.")
		}
```

**Verify:**
```bash
go build ./pkg/lexer
```

---

### Task 4: Test Identifier Scanning (45 minutes)

**Add tests to scanner_test.go:**

```go
func TestScanTokens_Identifiers(t *testing.T) {
	tests := []struct {
		source      string
		wantType    tokens.TokenType
		wantLexeme  string
	}{
		{"foo", tokens.IDENTIFIER, "foo"},
		{"bar123", tokens.IDENTIFIER, "bar123"},
		{"_test", tokens.IDENTIFIER, "_test"},
		{"camelCase", tokens.IDENTIFIER, "camelCase"},
		{"snake_case", tokens.IDENTIFIER, "snake_case"},
		{"UPPER", tokens.IDENTIFIER, "UPPER"},
		{"x", tokens.IDENTIFIER, "x"},
		{"_", tokens.IDENTIFIER, "_"},
		{"a1b2c3", tokens.IDENTIFIER, "a1b2c3"},
	}

	for _, tt := range tests {
		t.Run(tt.source, func(t *testing.T) {
			scanner := NewScanner(tt.source)
			toks, errs := scanner.ScanTokens()

			if len(errs) != 0 {
				t.Fatalf("unexpected errors: %v", errs)
			}

			if len(toks) != 2 { // IDENTIFIER + EOF
				t.Fatalf("got %d tokens, want 2", len(toks))
			}

			if toks[0].Type != tt.wantType {
				t.Errorf("token type = %v, want %v", toks[0].Type, tt.wantType)
			}

			if toks[0].Lexeme != tt.wantLexeme {
				t.Errorf("lexeme = %q, want %q", toks[0].Lexeme, tt.wantLexeme)
			}
		})
	}
}

func TestScanTokens_IdentifiersInCode(t *testing.T) {
	source := "var myVar = 42;"
	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("unexpected errors: %v", errs)
	}

	expected := []struct {
		tokenType tokens.TokenType
		lexeme    string
	}{
		{tokens.VAR, "var"},
		{tokens.IDENTIFIER, "myVar"},
		{tokens.EQUAL, "="},
		{tokens.NUMBER, "42"},
		{tokens.SEMICOLON, ";"},
		{tokens.EOF, ""},
	}

	if len(toks) != len(expected) {
		t.Fatalf("got %d tokens, want %d", len(toks), len(expected))
	}

	for i, exp := range expected {
		if toks[i].Type != exp.tokenType {
			t.Errorf("token[%d] type = %v, want %v",
				i, toks[i].Type, exp.tokenType)
		}
		if exp.lexeme != "" && toks[i].Lexeme != exp.lexeme {
			t.Errorf("token[%d] lexeme = %q, want %q",
				i, toks[i].Lexeme, exp.lexeme)
		}
	}
}

func TestScanTokens_IdentifiersWithNumbers(t *testing.T) {
	// Identifiers can contain digits but not start with them
	source := "var1 var2 var3"
	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("unexpected errors: %v", errs)
	}

	// Should have 3 identifiers + EOF
	identifiers := []string{"var1", "var2", "var3"}
	idCount := 0

	for _, tok := range toks {
		if tok.Type == tokens.IDENTIFIER {
			if idCount >= len(identifiers) {
				t.Fatal("too many identifiers")
			}
			if tok.Lexeme != identifiers[idCount] {
				t.Errorf("identifier[%d] = %q, want %q",
					idCount, tok.Lexeme, identifiers[idCount])
			}
			idCount++
		}
	}

	if idCount != len(identifiers) {
		t.Errorf("found %d identifiers, want %d", idCount, len(identifiers))
	}
}
```

**Run tests:**
```bash
go test ./pkg/lexer -v -run TestScanTokens_Identifiers
```

Expected: All tests pass

---

### Task 5: Manual REPL Testing (20 minutes)

**Test identifier scanning interactively:**

```bash
make build
./lox
```

**Test cases:**
```
> myVariable
IDENTIFIER myVariable <nil>
EOF  <nil>

> count1
IDENTIFIER count1 <nil>
EOF  <nil>

> _temp
IDENTIFIER _temp <nil>
EOF  <nil>

> CamelCase
IDENTIFIER CamelCase <nil>
EOF  <nil>

> snake_case
IDENTIFIER snake_case <nil>
EOF  <nil>

> var x = 10;
VAR var <nil>
IDENTIFIER x <nil>
EQUAL = <nil>
NUMBER 10 10
SEMICOLON ; <nil>
EOF  <nil>

> exit
```

**Verify:**
- All identifier forms work
- Identifiers with numbers work
- Identifiers with underscores work
- Identifiers in variable declarations work

---

## üìñ Resources

**Essential:**
- [Crafting Interpreters - Identifiers](https://craftinginterpreters.com/scanning.html#identifiers-and-keywords)
- [ASCII Table](https://www.asciitable.com/)
- [Go Character Classification](https://pkg.go.dev/unicode)

**Identifier Naming:**
- Lox uses similar rules to C, Java, JavaScript
- Case-sensitive: `MyVar` ‚â† `myvar`
- Can't start with digit (unlike CSS)

---

## ‚úÖ End-of-Day Checklist

- [ ] Implemented `isAlpha()` helper
- [ ] Implemented `isAlphaNumeric()` helper
- [ ] Implemented `scanIdentifier()` method
- [ ] Updated `scanToken()` to handle identifiers
- [ ] Written identifier tests - all passing
- [ ] Tested identifiers in REPL
- [ ] All tests pass: `go test ./pkg/lexer -v`
- [ ] Code committed to git (see below)

**Git commit:**
```bash
git add pkg/lexer/
git commit -m "feat: implement identifier scanning

- Add isAlpha() helper for letter/underscore detection
- Add isAlphaNumeric() helper for identifier bodies
- Implement scanIdentifier() method
- Support identifiers: myVar, _temp, count1, etc.
- Add comprehensive identifier tests
- Identifiers work with keywords (checked separately)

Day 12/30: Identifier scanning complete"
```

**Time Spent:** ~2.5 hours (20+30+35+45+20 = 150 minutes)

---

## üîó Navigation

- [‚Üê Day 011: Number Literals - Floats & Testing](Day-011.md)
- [‚Üí Day 013: Keywords vs Identifiers](Day-013.md)
- [‚Üë Month Overview](README.md)

---

## üìù Learning Notes

**Key Concepts:**

1. **Character Classification:**
   ```go
   // Letters or underscore
   isAlpha(c) ‚Üí (a-z) OR (A-Z) OR '_'

   // Letters, digits, or underscore
   isAlphaNumeric(c) ‚Üí isAlpha(c) OR isDigit(c)
   ```

2. **Identifier Scanning Pattern:**
   ```go
   // Already consumed first char (must be alpha)
   for isAlphaNumeric(s.peek()) {
       s.advance()
   }
   // Now have complete identifier
   ```

3. **Keyword vs Identifier:**
   - Scan as identifier first
   - Then check if it's a keyword
   - `tokens.LookupIdent(text)` does the lookup
   - Returns keyword type OR IDENTIFIER

4. **Valid Identifiers:**
   - Start: letter or `_`
   - Body: letter, digit, or `_`
   - Examples: `x`, `myVar`, `_temp`, `count1`

**Tomorrow's Preview:**
Focus on keyword vs identifier distinction:
- Test all 15 Lox keywords
- Ensure keywords are recognized
- Verify similar-looking identifiers work

---

*Progress: Day 12/30 complete* ‚≠ê
*Week 2: String & Number Literals*

**Commit your daily notes to Obsidian!**
