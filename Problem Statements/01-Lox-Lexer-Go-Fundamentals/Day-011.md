# Day 011: Number Literals - Floats & Testing

**Month 1:** Lox Lexer & Go Fundamentals
**Phase:** Foundation
**Week:** 2 of 4 - Literals & Advanced Scanning

---

## üéØ Today's Goal

Enhance number scanning to support floating-point literals with decimal points. By the end of today, your lexer will handle numbers like `123.456`, `0.5`, and distinguish between numbers and dot operators.

**What You'll Build:** Complete number scanning with decimal point support.

---

## üìö What You'll Learn Today

**Go Fundamentals:**
- Complex lookahead logic
- Conditional parsing based on context

**Compiler Concepts:**
- Contextual token recognition
- Distinguishing `.` as decimal vs operator
- Floating-point number parsing

---

## ‚úÖ Today's Tasks

### Task 1: Understand Decimal Point Rules (15 minutes)

**Key rules for decimal points in Lox:**

1. **Valid floats:**
   - `123.456` - Integer part + decimal part
   - `0.5` - Zero + decimal part
   - `999.0` - Integer + zero decimal

2. **NOT valid floats (these are multiple tokens):**
   - `.123` - This is DOT + NUMBER(123)
   - `123.` - This is NUMBER(123) + DOT

**The rule:** Only consume `.` if followed by a digit!

**Resources:**
- [Crafting Interpreters - Numbers](https://craftinginterpreters.com/scanning.html#literals)

---

### Task 2: Enhance scanNumber() with Decimal Support (40 minutes)

**What to do:**
Update `scanNumber()` to handle decimal points correctly.

**Open scanner.go and update scanNumber():**

```go
// scanNumber scans a number literal (integer or float)
func (s *Scanner) scanNumber() {
	// Consume all leading digits
	for isDigit(s.peek()) {
		s.advance()
	}

	// Look for a fractional part
	// Only consume '.' if followed by a digit
	if s.peek() == '.' && isDigit(s.peekNext()) {
		// Consume the decimal point
		s.advance()

		// Consume the fractional digits
		for isDigit(s.peek()) {
			s.advance()
		}
	}

	// Get the number text
	text := s.source[s.start:s.current]

	// Parse to float64
	value, err := strconv.ParseFloat(text, 64)
	if err != nil {
		s.addError(fmt.Sprintf("Invalid number: %s", text))
		return
	}

	s.addTokenLiteral(tokens.NUMBER, value)
}
```

**What changed:**
- Added check: `s.peek() == '.' && isDigit(s.peekNext())`
- Only consumes `.` if next character is a digit
- After consuming `.`, consumes all remaining digits

**Example walkthrough:**
```
Source: "123.456"
         ^
      start=0

1. Consume digits: "123"
2. See '.', peek next: '4' (is digit)
3. Consume '.': "123."
4. Consume digits: "123.456"
5. Parse: 123.456
```

**Verify:**
```bash
go build ./pkg/lexer
```

---

### Task 3: Test Floating-Point Numbers (45 minutes)

**Add comprehensive float tests to scanner_test.go:**

```go
func TestScanTokens_Numbers_Floats(t *testing.T) {
	tests := []struct {
		source      string
		wantLiteral float64
	}{
		{"0.0", 0.0},
		{"0.5", 0.5},
		{"123.456", 123.456},
		{"999.999", 999.999},
		{"1.0", 1.0},
		{"3.14159", 3.14159},
	}

	for _, tt := range tests {
		scanner := NewScanner(tt.source)
		toks, errs := scanner.ScanTokens()

		if len(errs) != 0 {
			t.Errorf("source %q: unexpected errors %v", tt.source, errs)
			continue
		}

		if len(toks) != 2 { // NUMBER + EOF
			t.Fatalf("source %q: got %d tokens, want 2", tt.source, len(toks))
		}

		if toks[0].Type != tokens.NUMBER {
			t.Errorf("source %q: token type = %v, want NUMBER",
				tt.source, toks[0].Type)
		}

		if toks[0].Literal != tt.wantLiteral {
			t.Errorf("source %q: literal = %v, want %v",
				tt.source, toks[0].Literal, tt.wantLiteral)
		}
	}
}

func TestScanTokens_Numbers_DecimalPointEdgeCases(t *testing.T) {
	tests := []struct {
		name        string
		source      string
		wantTokens  []tokens.TokenType
		wantLiteral interface{} // For the number token
	}{
		{
			name:        "number then dot operator",
			source:      "123.",
			wantTokens:  []tokens.TokenType{tokens.NUMBER, tokens.DOT, tokens.EOF},
			wantLiteral: 123.0,
		},
		{
			name:        "dot then number",
			source:      ".123",
			wantTokens:  []tokens.TokenType{tokens.DOT, tokens.NUMBER, tokens.EOF},
			wantLiteral: 123.0, // Second token
		},
		{
			name:        "method call chain",
			source:      "obj.method",
			wantTokens:  []tokens.TokenType{tokens.IDENTIFIER, tokens.DOT, tokens.IDENTIFIER, tokens.EOF},
			wantLiteral: nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			scanner := NewScanner(tt.source)
			toks, errs := scanner.ScanTokens()

			if len(errs) != 0 {
				t.Fatalf("unexpected errors: %v", errs)
			}

			if len(toks) != len(tt.wantTokens) {
				t.Fatalf("got %d tokens, want %d", len(toks), len(tt.wantTokens))
			}

			for i, wantType := range tt.wantTokens {
				if toks[i].Type != wantType {
					t.Errorf("token[%d] type = %v, want %v",
						i, toks[i].Type, wantType)
				}
			}
		})
	}
}

func TestScanTokens_Numbers_FloatsInExpressions(t *testing.T) {
	source := "1.5 + 2.3 * 3.7"
	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("unexpected errors: %v", errs)
	}

	expected := []struct {
		tokenType tokens.TokenType
		literal   interface{}
	}{
		{tokens.NUMBER, 1.5},
		{tokens.PLUS, nil},
		{tokens.NUMBER, 2.3},
		{tokens.STAR, nil},
		{tokens.NUMBER, 3.7},
		{tokens.EOF, nil},
	}

	if len(toks) != len(expected) {
		t.Fatalf("got %d tokens, want %d", len(toks), len(expected))
	}

	for i, exp := range expected {
		if toks[i].Type != exp.tokenType {
			t.Errorf("token[%d] type = %v, want %v",
				i, toks[i].Type, exp.tokenType)
		}
		if exp.literal != nil && toks[i].Literal != exp.literal {
			t.Errorf("token[%d] literal = %v, want %v",
				i, toks[i].Literal, exp.literal)
		}
	}
}
```

**Run tests:**
```bash
go test ./pkg/lexer -v -run TestScanTokens_Numbers
```

Expected: All tests pass

---

### Task 4: Integration Testing (30 minutes)

**Test floats in realistic scenarios:**

```go
func TestScanTokens_FloatsWithVariables(t *testing.T) {
	source := `var pi = 3.14159;
var half = 0.5;
var result = pi * 2.0;`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("unexpected errors: %v", errs)
	}

	// Find all NUMBER tokens and verify they're floats
	numberCount := 0
	expectedNumbers := []float64{3.14159, 0.5, 2.0}

	for _, tok := range toks {
		if tok.Type == tokens.NUMBER {
			if numberCount >= len(expectedNumbers) {
				t.Fatalf("too many NUMBER tokens")
			}
			expected := expectedNumbers[numberCount]
			if tok.Literal != expected {
				t.Errorf("number[%d] = %v, want %v",
					numberCount, tok.Literal, expected)
			}
			numberCount++
		}
	}

	if numberCount != len(expectedNumbers) {
		t.Errorf("found %d numbers, want %d", numberCount, len(expectedNumbers))
	}
}
```

**Run:**
```bash
go test ./pkg/lexer -v -run TestScanTokens_Floats
```

---

### Task 5: Manual REPL Testing (25 minutes)

**Test float scanning interactively:**

```bash
make build
./lox
```

**Test cases:**
```
> 3.14
NUMBER 3.14 3.14
EOF  <nil>

> 0.5
NUMBER 0.5 0.5
EOF  <nil>

> 123.456
NUMBER 123.456 123.456
EOF  <nil>

> 1.0 + 2.5
NUMBER 1 1
PLUS + <nil>
NUMBER 2.5 2.5
EOF  <nil>

> 123.
NUMBER 123 123
DOT . <nil>
EOF  <nil>

> .456
DOT . <nil>
NUMBER 456 456
EOF  <nil>

> obj.method
IDENTIFIER obj <nil>
DOT . <nil>
IDENTIFIER method <nil>
EOF  <nil>

> exit
```

**Verify:**
- Floats scan correctly
- `123.` produces NUMBER then DOT (two tokens)
- `.456` produces DOT then NUMBER (two tokens)
- Method calls work (DOT not consumed as decimal)

---

### Task 6: Run Full Test Suite (15 minutes)

**Run all lexer tests:**
```bash
go test ./pkg/lexer -v
```

**Check for:**
- All tests passing
- No regressions from previous days
- Good test coverage

**If any tests fail:**
1. Read the error message carefully
2. Check your scanNumber() logic
3. Verify the peek/peekNext calls
4. Add debug prints if needed

---

## üìñ Resources

**Essential:**
- [Crafting Interpreters - Numbers](https://craftinginterpreters.com/scanning.html#literals)
- [Go strconv.ParseFloat](https://pkg.go.dev/strconv#ParseFloat)
- [Floating Point Precision](https://go.dev/blog/float64)

---

## ‚úÖ End-of-Day Checklist

- [ ] Updated `scanNumber()` with decimal point logic
- [ ] Written float number tests - all passing
- [ ] Written edge case tests (123., .456) - all passing
- [ ] Written integration tests - all passing
- [ ] Tested floats in REPL manually
- [ ] Verified method calls still work (obj.method)
- [ ] All tests pass: `go test ./pkg/lexer -v`
- [ ] Code committed to git (see below)

**Git commit:**
```bash
git add pkg/lexer/
git commit -m "feat: add floating-point number support

- Enhance scanNumber() with decimal point detection
- Only consume '.' if followed by digit (peekNext check)
- Support floats: 123.456, 0.5, etc.
- Handle edge cases: 123. and .456 are NOT floats
- Add comprehensive float tests
- Verify method calls (obj.method) still work

Day 11/30: Float number scanning complete"
```

**Time Spent:** ~2.5 hours (15+40+45+30+25+15 = 170 minutes)

---

## üîó Navigation

- [‚Üê Day 010: Number Literal Scanning (Part 1)](Day-010.md)
- [‚Üí Day 012: Identifier Scanning](Day-012.md)
- [‚Üë Month Overview](README.md)

---

## üìù Learning Notes

**Key Concepts:**

1. **Decimal Point Logic:**
   ```go
   // Only consume '.' if followed by digit
   if s.peek() == '.' && isDigit(s.peekNext()) {
       s.advance() // Consume '.'
       // Then consume fractional digits
   }
   ```

2. **Why This Matters:**
   - `123.456` ‚Üí ONE token: NUMBER(123.456)
   - `123.` ‚Üí TWO tokens: NUMBER(123), DOT
   - `.456` ‚Üí TWO tokens: DOT, NUMBER(456)
   - `obj.method` ‚Üí THREE tokens: IDENTIFIER, DOT, IDENTIFIER

3. **Lookahead Pattern:**
   - Need to check TWO positions ahead
   - Current: `.`
   - Next: must be digit
   - Both conditions required to consume `.`

4. **Testing Strategy:**
   - Test valid floats
   - Test edge cases (no digit after `.`)
   - Test integration with other tokens
   - Verify no regressions

**Tomorrow's Preview:**
Implement identifier scanning:
- Detecting letters and underscores
- Consuming alphanumeric sequences
- Using the keyword lookup map

---

*Progress: Day 11/30 complete* ‚≠ê
*Week 2: String & Number Literals*

**Commit your daily notes to Obsidian!**
