# Day 009: String Literals - Multiline & Error Handling

**Month 1:** Lox Lexer & Go Fundamentals
**Phase:** Foundation
**Week:** 2 of 4 - Literals & Advanced Scanning

---

## ğŸ¯ Today's Goal

Enhance string literal scanning to handle multiline strings and unterminated string errors. By the end of today, your lexer will properly track line numbers within strings and report helpful error messages for unterminated strings.

**What You'll Build:** Enhanced string scanning with multiline support and robust error handling.

---

## ğŸ“š What You'll Learn Today

**Go Fundamentals:**
- Line tracking across multiple lines
- Error reporting best practices
- Testing error conditions

**Compiler Concepts:**
- Multiline token handling
- Error recovery in lexers
- Line number tracking for debugging

**Crafting Interpreters:**
- Section 4.6 (continued) - Multiline strings and error handling

---

## âœ… Today's Tasks

### Task 1: Understand Multiline String Requirements (15 minutes)

**What to do:**
Review the requirements for multiline strings in Lox.

**Key concepts:**
1. Lox allows strings to span multiple lines
2. When a newline is encountered inside a string, we must increment the line counter
3. Unterminated strings (missing closing `"`) should produce an error
4. The error should report the line where the string started

**Example multiline string:**
```lox
var poem = "Roses are red,
Violets are blue,
Lox is cool,
And so are you!";
```

This is valid Lox code and should create a single STRING token with the literal value containing actual newlines.

**Resources:**
- [Crafting Interpreters - String Literals](https://craftinginterpreters.com/scanning.html#string-literals)

---

### Task 2: Add Line Tracking to scanString() (30 minutes)

**What to do:**
Modify your `scanString()` method to properly track line numbers when newlines appear inside strings.

**Step-by-step:**

1. **Open scanner.go:**
```bash
cd /home/bhargav/Documents/Side-Projects/konfiguru
code pkg/lexer/scanner.go
```

2. **Update scanString() to track newlines:**

Find your `scanString()` method and modify it:

```go
// scanString scans a string literal
func (s *Scanner) scanString() {
	// Consume characters until we hit the closing quote or end of file
	for s.peek() != '"' && !s.isAtEnd() {
		// Track line numbers for newlines inside strings
		if s.peek() == '\n' {
			s.line++
		}
		s.advance()
	}

	if s.isAtEnd() {
		s.addError("Unterminated string.")
		return
	}

	// Consume the closing "
	s.advance()

	// Trim the surrounding quotes to get the actual string value
	value := s.source[s.start+1 : s.current-1]
	s.addTokenLiteral(tokens.STRING, value)
}
```

**What changed:**
- Added `if s.peek() == '\n'` check inside the loop
- Increments `s.line++` when a newline is found
- This ensures line tracking stays accurate even with multiline strings

**Verify the code compiles:**
```bash
go build ./pkg/lexer
```

---

### Task 3: Test Multiline Strings (40 minutes)

**What to do:**
Write tests to verify multiline string handling works correctly.

**Add test to scanner_test.go:**

```go
func TestScanTokens_MultilineString(t *testing.T) {
	source := `"hello
world"`
	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("unexpected errors: %v", errs)
	}

	if len(toks) != 2 { // STRING + EOF
		t.Fatalf("got %d tokens, want 2", len(toks))
	}

	// Verify token type
	if toks[0].Type != tokens.STRING {
		t.Errorf("token type = %v, want STRING", toks[0].Type)
	}

	// Verify the literal includes the newline
	expected := "hello\nworld"
	if toks[0].Literal != expected {
		t.Errorf("literal = %q, want %q", toks[0].Literal, expected)
	}

	// Verify line tracking: string started on line 1
	if toks[0].Line != 1 {
		t.Errorf("token line = %d, want 1", toks[0].Line)
	}

	// After scanning the multiline string, we should be on line 2
	if scanner.line != 2 {
		t.Errorf("scanner.line = %d, want 2", scanner.line)
	}
}

func TestScanTokens_MultilineString_MultipleLines(t *testing.T) {
	source := `"line 1
line 2
line 3"`
	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("unexpected errors: %v", errs)
	}

	// Check the literal value
	expected := "line 1\nline 2\nline 3"
	if toks[0].Literal != expected {
		t.Errorf("literal = %q, want %q", toks[0].Literal, expected)
	}

	// Scanner should be on line 3 after the string
	if scanner.line != 3 {
		t.Errorf("scanner.line = %d, want 3", scanner.line)
	}
}
```

**Run the tests:**
```bash
go test ./pkg/lexer -v -run TestScanTokens_MultilineString
```

Expected: All tests pass

---

### Task 4: Test Unterminated Strings (35 minutes)

**What to do:**
Write tests to verify that unterminated strings produce proper error messages.

**Add error tests to scanner_test.go:**

```go
func TestScanTokens_UnterminatedString(t *testing.T) {
	tests := []struct {
		name   string
		source string
	}{
		{
			name:   "simple unterminated string",
			source: `"hello`,
		},
		{
			name:   "unterminated string at end of file",
			source: `var x = "test`,
		},
		{
			name:   "multiline unterminated string",
			source: `"line 1
line 2
line 3`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			scanner := NewScanner(tt.source)
			_, errs := scanner.ScanTokens()

			// Should have at least one error
			if len(errs) == 0 {
				t.Errorf("expected error for unterminated string, got none")
			}

			// Error message should mention "Unterminated string"
			found := false
			for _, err := range errs {
				if strings.Contains(err, "Unterminated string") {
					found = true
					break
				}
			}

			if !found {
				t.Errorf("error message should contain 'Unterminated string', got: %v", errs)
			}
		})
	}
}

func TestScanTokens_StringErrorLineNumber(t *testing.T) {
	// String starts on line 2 and is unterminated
	source := `var x = 5;
"unterminated`

	scanner := NewScanner(source)
	_, errs := scanner.ScanTokens()

	if len(errs) == 0 {
		t.Fatal("expected error, got none")
	}

	// Error should reference line 2 (where the string started)
	errorMsg := errs[0]
	if !strings.Contains(errorMsg, "line 2") {
		t.Errorf("error should reference line 2, got: %s", errorMsg)
	}
}
```

**Note:** Add the import for strings package at the top of scanner_test.go if not already there:
```go
import (
	"strings"
	"testing"

	"github.com/bhargav/konfiguru/pkg/tokens"
)
```

**Run the tests:**
```bash
go test ./pkg/lexer -v -run TestScanTokens_Unterminated
go test ./pkg/lexer -v -run TestScanTokens_StringError
```

---

### Task 5: Integration Testing with Multiline Strings (30 minutes)

**What to do:**
Test multiline strings in realistic code scenarios.

**Add integration test:**

```go
func TestScanTokens_MultilineStringInCode(t *testing.T) {
	source := `var message = "Hello,
World!
This is Lox.";
print message;`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("unexpected errors: %v", errs)
	}

	// Expected tokens: VAR IDENTIFIER EQUAL STRING SEMICOLON PRINT IDENTIFIER SEMICOLON EOF
	expected := []tokens.TokenType{
		tokens.VAR,
		tokens.IDENTIFIER,
		tokens.EQUAL,
		tokens.STRING,
		tokens.SEMICOLON,
		tokens.PRINT,
		tokens.IDENTIFIER,
		tokens.SEMICOLON,
		tokens.EOF,
	}

	if len(toks) != len(expected) {
		t.Fatalf("got %d tokens, want %d", len(toks), len(expected))
	}

	for i, exp := range expected {
		if toks[i].Type != exp {
			t.Errorf("token[%d] type = %v, want %v", i, toks[i].Type, exp)
		}
	}

	// Verify the string literal
	stringToken := toks[3]
	expectedLiteral := "Hello,\nWorld!\nThis is Lox."
	if stringToken.Literal != expectedLiteral {
		t.Errorf("string literal = %q, want %q", stringToken.Literal, expectedLiteral)
	}

	// The print statement should be on line 4 (after the 3-line string)
	printToken := toks[5]
	if printToken.Line != 4 {
		t.Errorf("print token line = %d, want 4", printToken.Line)
	}
}
```

**Run all string tests:**
```bash
go test ./pkg/lexer -v -run String
```

---

### Task 6: Manual REPL Testing (20 minutes)

**What to do:**
Test multiline strings and errors interactively.

**Build and test:**
```bash
make build
./lox
```

**Test multiline strings:**
```
> "hello
... world"
STRING "hello
world" hello
world
EOF  <nil>

> var msg = "line 1
... line 2
... line 3";
VAR var <nil>
IDENTIFIER msg <nil>
EQUAL = <nil>
STRING "line 1
line 2
line 3" line 1
line 2
line 3
SEMICOLON ; <nil>
EOF  <nil>
```

**Test unterminated string:**
```
> "unterminated
[line 1] Error: Unterminated string.

> exit
```

**What to verify:**
- Multiline strings work correctly
- Line numbers are tracked properly
- Unterminated strings produce errors
- Error messages are helpful

---

## ğŸ“– Resources

**Essential:**
- [Crafting Interpreters - String Literals](https://craftinginterpreters.com/scanning.html#string-literals)
- [Go Error Handling](https://go.dev/blog/error-handling-and-go)
- [Go strings package](https://pkg.go.dev/strings)

**String Testing:**
- Test both valid and invalid inputs
- Verify error messages are helpful
- Check line number tracking

---

## âœ… End-of-Day Checklist

- [ ] Updated `scanString()` with newline tracking
- [ ] Written multiline string tests - all passing
- [ ] Written unterminated string error tests - all passing
- [ ] Written integration tests with realistic code
- [ ] Tested in REPL manually
- [ ] All tests pass: `go test ./pkg/lexer -v`
- [ ] Code committed to git (see below)

**Git commit:**
```bash
git add pkg/lexer/
git commit -m "feat: add multiline string support and error handling

- Track line numbers within strings (increment on \n)
- Report errors for unterminated strings
- Add comprehensive tests for multiline strings
- Add error tests for unterminated strings
- Verify line number tracking is accurate

Day 9/30: Enhanced string scanning complete"
```

**Time Spent:** ~2.5 hours (15+30+40+35+30+20 = 170 minutes)

---

## ğŸ”— Navigation

- [â† Day 008: String Literal Scanning (Part 1)](Day-008.md)
- [â†’ Day 010: Number Literal Scanning (Part 1)](Day-010.md)
- [â†‘ Month Overview](README.md)

---

## ğŸ“ Learning Notes

**Key Concepts Learned:**

1. **Multiline Token Handling:**
   - Tokens can span multiple lines
   - Must track line numbers accurately within tokens
   - Line number in token refers to where token started

2. **Error Reporting:**
   - Report errors but continue scanning
   - Include line number in error messages
   - Make error messages helpful for developers

3. **Line Tracking Logic:**
   ```go
   // Inside scanString()
   if s.peek() == '\n' {
       s.line++  // Increment for each newline in string
   }
   ```

4. **Unterminated String Detection:**
   ```go
   if s.isAtEnd() {
       s.addError("Unterminated string.")
       return  // Don't create a token
   }
   ```

**Testing Strategy:**
- Test happy path (valid multiline strings)
- Test error path (unterminated strings)
- Verify line tracking is accurate
- Test integration with other tokens

**Common Issues:**
- Forgetting to increment line counter inside strings
- Not checking for EOF inside string loop
- Poor error messages that don't help debugging

**Tomorrow's Preview:**
You'll implement number literal scanning:
- Detecting digits
- Handling integers
- Supporting decimal points for floats

---

*Progress: Day 9/30 complete* â­
*Week 2: String & Number Literals*

**Commit your daily notes to Obsidian!**
