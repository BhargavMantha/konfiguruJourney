# Day 014: Week 2 Integration Testing & Review

**Month 1:** Lox Lexer & Go Fundamentals
**Phase:** Foundation
**Week:** 2 of 4 - Literals & Advanced Scanning

---

## ðŸŽ¯ Today's Goal

Review Week 2 progress, write integration tests for all features working together, and verify the lexer handles complex Lox programs. Prepare for Week 3 by reviewing what's left to implement.

**What You'll Build:** Comprehensive integration tests and week review.

---

## ðŸ“š What You'll Learn Today

**Go Fundamentals:**
- Integration testing patterns
- Test organization strategies
- Code review techniques

**Compiler Concepts:**
- End-to-end tokenization testing
- Real-world program scanning
- Feature integration verification

---

## âœ… Today's Tasks

### Task 1: Week 2 Review (30 minutes)

**What you accomplished this week:**

âœ… **Day 8:** String literal scanning (basic)
- `scanString()` method
- Quote handling
- String value extraction

âœ… **Day 9:** String multiline & error handling
- Line tracking in strings
- Unterminated string errors
- Multiline string support

âœ… **Day 10:** Number literal scanning (integers)
- `isDigit()` helper
- `peekNext()` for lookahead
- `scanNumber()` for integers

âœ… **Day 11:** Number literals (floats)
- Decimal point detection
- Float parsing
- Edge cases (123., .456)

âœ… **Day 12:** Identifier scanning
- `isAlpha()` and `isAlphaNumeric()` helpers
- `scanIdentifier()` method
- Alphanumeric name support

âœ… **Day 13:** Keywords vs identifiers
- Keyword recognition
- Case sensitivity
- Comprehensive keyword tests

**Verify your current test coverage:**
```bash
go test ./pkg/lexer -v
```

All tests should be passing!

---

### Task 2: Write Complete Program Integration Tests (60 minutes)

**Create comprehensive integration tests:**

**Add to a new file: `pkg/lexer/integration_week2_test.go`:**

```go
package lexer

import (
	"testing"

	"github.com/bhargav/konfiguru/pkg/tokens"
)

func TestWeek2_CompleteVariableProgram(t *testing.T) {
	source := `var name = "Alice";
var age = 25;
var pi = 3.14159;
var isActive = true;

print name;
print age;
print pi;`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("unexpected errors: %v", errs)
	}

	// Verify we have the right number of var keywords
	varCount := 0
	printCount := 0
	for _, tok := range toks {
		if tok.Type == tokens.VAR {
			varCount++
		}
		if tok.Type == tokens.PRINT {
			printCount++
		}
	}

	if varCount != 4 {
		t.Errorf("got %d var keywords, want 4", varCount)
	}
	if printCount != 3 {
		t.Errorf("got %d print keywords, want 3", printCount)
	}
}

func TestWeek2_CompleteIfElseProgram(t *testing.T) {
	source := `if (age >= 18) {
    print "Adult";
} else {
    print "Minor";
}`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("unexpected errors: %v", errs)
	}

	// Check for key token types
	hasIf := false
	hasElse := false
	stringCount := 0

	for _, tok := range toks {
		if tok.Type == tokens.IF {
			hasIf = true
		}
		if tok.Type == tokens.ELSE {
			hasElse = true
		}
		if tok.Type == tokens.STRING {
			stringCount++
		}
	}

	if !hasIf {
		t.Error("missing IF keyword")
	}
	if !hasElse {
		t.Error("missing ELSE keyword")
	}
	if stringCount != 2 {
		t.Errorf("got %d strings, want 2", stringCount)
	}
}

func TestWeek2_CompleteFunctionProgram(t *testing.T) {
	source := `fun greet(name) {
    var message = "Hello, " + name;
    print message;
    return true;
}

var result = greet("World");
print result;`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("unexpected errors: %v", errs)
	}

	// Verify all expected keywords are present
	keywordCounts := make(map[tokens.TokenType]int)
	for _, tok := range toks {
		keywordCounts[tok.Type]++
	}

	expected := map[tokens.TokenType]int{
		tokens.FUN:    1,
		tokens.VAR:    2,
		tokens.PRINT:  2,
		tokens.RETURN: 1,
	}

	for keyword, expectedCount := range expected {
		if keywordCounts[keyword] != expectedCount {
			t.Errorf("keyword %v: got %d, want %d",
				keyword, keywordCounts[keyword], expectedCount)
		}
	}
}

func TestWeek2_CompleteLoopProgram(t *testing.T) {
	source := `for (var i = 0; i < 10; i = i + 1) {
    print i;
}

var count = 0;
while (count < 5) {
    print count;
    count = count + 1;
}`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("unexpected errors: %v", errs)
	}

	// Check for loop keywords
	hasFor := false
	hasWhile := false

	for _, tok := range toks {
		if tok.Type == tokens.FOR {
			hasFor = true
		}
		if tok.Type == tokens.WHILE {
			hasWhile = true
		}
	}

	if !hasFor {
		t.Error("missing FOR keyword")
	}
	if !hasWhile {
		t.Error("missing WHILE keyword")
	}
}

func TestWeek2_ComplexExpressions(t *testing.T) {
	source := `var result = (10 + 20) * 3.5 - 7 / 2.0;
var check = true and (x > 5 or y < 10);
var name = "John" + " " + "Doe";`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("unexpected errors: %v", errs)
	}

	// Count literals
	numberCount := 0
	stringCount := 0

	for _, tok := range toks {
		if tok.Type == tokens.NUMBER {
			numberCount++
		}
		if tok.Type == tokens.STRING {
			stringCount++
		}
	}

	// Should have multiple numbers and strings
	if numberCount < 5 {
		t.Errorf("got %d numbers, want at least 5", numberCount)
	}
	if stringCount < 3 {
		t.Errorf("got %d strings, want at least 3", stringCount)
	}
}

func TestWeek2_ClassProgram(t *testing.T) {
	source := `class Point {
    fun init(x, y) {
        this.x = x;
        this.y = y;
    }

    fun distance() {
        return (this.x * this.x + this.y * this.y);
    }
}

var p = Point();`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("unexpected errors: %v", errs)
	}

	// Check for class-related keywords
	keywordCounts := make(map[tokens.TokenType]int)
	for _, tok := range toks {
		keywordCounts[tok.Type]++
	}

	if keywordCounts[tokens.CLASS] != 1 {
		t.Error("missing CLASS keyword")
	}
	if keywordCounts[tokens.THIS] < 3 {
		t.Errorf("got %d THIS keywords, want at least 3", keywordCounts[tokens.THIS])
	}
	if keywordCounts[tokens.FUN] < 2 {
		t.Errorf("got %d FUN keywords, want at least 2", keywordCounts[tokens.FUN])
	}
}
```

**Run integration tests:**
```bash
go test ./pkg/lexer -v -run TestWeek2
```

Expected: All integration tests pass

---

### Task 3: Test Error Handling (30 minutes)

**Test that errors are properly reported:**

**Add to integration_week2_test.go:**

```go
func TestWeek2_ErrorHandling(t *testing.T) {
	tests := []struct {
		name          string
		source        string
		wantErrorCount int
		errorContains string
	}{
		{
			name:           "unterminated string",
			source:         `var x = "hello`,
			wantErrorCount: 1,
			errorContains:  "Unterminated string",
		},
		{
			name:           "unexpected character",
			source:         "var x @ 5;",
			wantErrorCount: 1,
			errorContains:  "Unexpected character",
		},
		{
			name: "multiple errors",
			source: `var x = "unterminated
var y @ 5;`,
			wantErrorCount: 2,
			errorContains:  "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			scanner := NewScanner(tt.source)
			_, errs := scanner.ScanTokens()

			if len(errs) != tt.wantErrorCount {
				t.Errorf("got %d errors, want %d: %v",
					len(errs), tt.wantErrorCount, errs)
			}

			if tt.errorContains != "" {
				found := false
				for _, err := range errs {
					if strings.Contains(err, tt.errorContains) {
						found = true
						break
					}
				}
				if !found {
					t.Errorf("errors should contain %q, got: %v",
						tt.errorContains, errs)
				}
			}
		})
	}
}
```

**Add strings import if needed:**
```go
import (
	"strings"
	"testing"

	"github.com/bhargav/konfiguru/pkg/tokens"
)
```

**Run:**
```bash
go test ./pkg/lexer -v -run TestWeek2_Error
```

---

### Task 4: Run Complete Test Suite (20 minutes)

**Run all tests with coverage:**
```bash
# All tests
go test ./... -v

# With coverage
go test ./pkg/lexer -cover

# Detailed coverage
go test ./pkg/lexer -coverprofile=coverage.out
go tool cover -html=coverage.out
```

**Verify:**
- All tests passing
- Good code coverage (aim for >80%)
- No skipped tests
- No test failures

---

### Task 5: Create Example Lox Files (20 minutes)

**Create example files for manual testing:**

**Create: `examples/week2_variables.lox`:**
```lox
// Week 2 Example: Variables and Literals

var name = "Alice";
var age = 25;
var pi = 3.14159;
var isActive = true;
var nothing = nil;

print name;
print age;
print pi;
print isActive;
print nothing;
```

**Create: `examples/week2_expressions.lox`:**
```lox
// Week 2 Example: Complex Expressions

var x = 10;
var y = 20;

var sum = x + y;
var product = x * y;
var difference = x - y;
var quotient = y / x;

print "Sum: " + sum;
print "Product: " + product;

var result = (x + y) * 2.5 - 7 / 3.5;
print result;

var check = true and (x > 5 or y < 100);
print check;
```

**Test them:**
```bash
make build
./lox examples/week2_variables.lox
./lox examples/week2_expressions.lox
```

**Verify:** All tokens scan correctly, no errors

---

### Task 6: Week Review & Planning (30 minutes)

**Document your progress:**

Create a file: `docs/week-2-review.md`:

```markdown
# Week 2 Review: String & Number Literals

**Dates:** [Fill in your dates]
**Time Spent:** ~13.5 hours

---

## What We Built

### String Literal Scanning
- Basic string scanning with quote handling
- Multiline string support
- Line number tracking within strings
- Error handling for unterminated strings

### Number Literal Scanning
- Integer number scanning
- Floating-point number support
- Decimal point detection with lookahead
- Edge case handling (123., .456)

### Identifier & Keyword Scanning
- Identifier scanning (alphanumeric + underscore)
- Keyword recognition (all 15 Lox keywords)
- Case-sensitive keyword matching
- Distinction between keywords and identifiers

---

## Skills Learned

### Go Concepts
- String slicing and manipulation
- Character classification (isDigit, isAlpha)
- Multi-character lookahead (peek, peekNext)
- Map-based keyword lookup
- Table-driven test patterns

### Compiler Concepts
- Literal value extraction
- Contextual token recognition
- Line number tracking for errors
- Lookahead for disambiguation

---

## Test Statistics

- Total tests: [Run `go test ./pkg/lexer -v | grep PASS | wc -l`]
- Test coverage: [Run `go test ./pkg/lexer -cover`]
- Integration tests: 7 comprehensive scenarios

---

## What's Next (Week 3)

Based on the Month 1 plan, Week 3 will focus on:
- **Remaining lexer features** (if any)
- **Lexer polish and optimization**
- **Complete lexer test coverage**
- **REPL improvements**
- **Documentation**

---

## Reflections

**What went well:**
- [Your notes]

**What was challenging:**
- [Your notes]

**What I learned:**
- [Your notes]

**Questions for Week 3:**
- [Your notes]
```

**Fill in your actual stats and reflections!**

---

## ðŸ“– Resources

**Testing:**
- [Go Testing Package](https://pkg.go.dev/testing)
- [Table-Driven Tests in Go](https://dave.cheney.net/2019/05/07/prefer-table-driven-tests)
- [Integration Testing Patterns](https://go.dev/doc/tutorial/add-a-test)

---

## âœ… End-of-Day Checklist

- [ ] Reviewed Week 2 progress
- [ ] Written integration tests - all passing
- [ ] Written error handling tests - all passing
- [ ] Run complete test suite - all passing
- [ ] Created example Lox files
- [ ] Tested examples manually
- [ ] Created week review document
- [ ] All tests pass: `go test ./... -v`
- [ ] Code committed to git (see below)

**Git commit:**
```bash
git add .
git commit -m "test: Week 2 integration tests and review

- Add comprehensive integration tests for complete programs
- Test variables, functions, loops, classes
- Test complex expressions with all literal types
- Add error handling integration tests
- Create example Lox files for manual testing
- Document Week 2 progress and learnings

Day 14/30: Week 2 complete - String & Number literals mastered"
```

**Time Spent:** ~2.5 hours (30+60+30+20+20+30 = 190 minutes)

---

## ðŸ”— Navigation

- [â† Day 013: Keywords vs Identifiers](Day-013.md)
- [â†’ Day 015: Week 3 Preview](Day-015.md)
- [â†‘ Month Overview](README.md)

---

## ðŸ“ Learning Notes

**Week 2 Achievements:**

1. **Complete Literal Scanning:**
   - Strings (with multiline support)
   - Numbers (integers and floats)
   - Proper error handling

2. **Identifier & Keyword System:**
   - Alphanumeric identifier scanning
   - All 15 keywords recognized
   - Case-sensitive distinction

3. **Testing Maturity:**
   - Unit tests for each feature
   - Integration tests for real programs
   - Error handling tests
   - Manual REPL testing

4. **Code Organization:**
   - Clean separation of concerns
   - Helper functions (isDigit, isAlpha, etc.)
   - Reusable scanning patterns

**Key Takeaways:**
- Lookahead is crucial for contextual scanning
- Test-driven development catches bugs early
- Integration tests verify features work together
- Error handling is as important as happy path

**Week 3 Preview:**
Based on the implementation plan (Task 10-12), Week 3 will likely cover:
- Integration testing
- CLI/REPL improvements
- Documentation and polish
- Final lexer completion

---

*Progress: Day 14/30 complete* â­
*Week 2: COMPLETE - String & Number Literals*

**Excellent work! Week 2 is done. Take Sunday to rest, then start Week 3 on Monday!**

**Commit your weekly notes to Obsidian!**
