# Day 020: File-based Scanning & Final Polish

**Month 1:** Lox Lexer & Go Fundamentals
**Phase:** Foundation
**Week:** 3 of 4 - Integration Testing & REPL Development

---

## üéØ Today's Goal

Complete file scanning support, improve error reporting, and add final polish to the lexer. Ensure all real Lox programs scan correctly.

**What You'll Build:** Production-ready lexer with excellent error messages and file support.

---

## üìö What You'll Learn Today

**Go Fundamentals:**
- File path handling
- Better error messages
- Code refactoring

**Software Engineering:**
- Code quality and polish
- User-facing error messages
- Production readiness

---

## ‚úÖ Today's Tasks

### Task 1: Improve Error Messages (45 minutes)

**Enhance error reporting in `pkg/lexer/scanner.go`:**

```go
// addError records a scanning error with context
func (s *Scanner) addError(message string) {
	// Get the line content for context
	lineStart := s.start
	for lineStart > 0 && s.source[lineStart-1] != '\n' {
		lineStart--
	}

	lineEnd := s.current
	for lineEnd < len(s.source) && s.source[lineEnd] != '\n' {
		lineEnd++
	}

	lineContent := s.source[lineStart:lineEnd]

	// Calculate column position
	column := s.start - lineStart + 1

	// Build error message
	errMsg := fmt.Sprintf("[line %d:%d] Error: %s", s.line, column, message)
	s.errors = append(s.errors, errMsg)

	// Add line content for context
	if lineContent != "" {
		s.errors = append(s.errors, fmt.Sprintf("  %s", lineContent))
		pointer := strings.Repeat(" ", column+1) + "^"
		s.errors = append(s.errors, pointer)
	}
}
```

This gives much better errors:
```
[line 3:10] Error: Unterminated string.
  var x = "hello
           ^
```

---

### Task 2: Test Complex Lox Files (60 minutes)

**Create realistic Lox programs:**

**`examples/fibonacci.lox`:**
```lox
// Fibonacci sequence calculator

fun fibonacci(n) {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

for (var i = 0; i < 10; i = i + 1) {
    print fibonacci(i);
}
```

**`examples/calculator.lox`:**
```lox
// Simple calculator

var x = 10;
var y = 5;

print "Addition: ";
print x + y;

print "Subtraction: ";
print x - y;

print "Multiplication: ";
print x * y;

print "Division: ";
print x / y;

print "Comparison: ";
print x > y;
print x < y;
print x == y;
print x != y;
```

**`examples/objects.lox`:**
```lox
// Object-oriented example

class Animal {
    fun init(name) {
        this.name = name;
    }

    fun speak() {
        print this.name + " makes a sound";
    }
}

class Dog {
    fun init(name, breed) {
        this.name = name;
        this.breed = breed;
    }

    fun bark() {
        print this.name + " says woof!";
    }

    fun describe() {
        print this.name + " is a " + this.breed;
    }
}

var dog = Dog("Buddy", "Golden Retriever");
dog.bark();
dog.describe();
```

**Test all files:**
```bash
./lox examples/fibonacci.lox
./lox examples/calculator.lox
./lox examples/objects.lox
```

---

### Task 3: Add File Statistics (30 minutes)

**Show useful stats after scanning:**

In `cmd/lox/main.go`, update `run()`:

```go
func run(source string) bool {
	scanner := lexer.NewScanner(source)
	tokens, errors := scanner.ScanTokens()

	if len(errors) > 0 {
		fmt.Println()
		fmt.Println("Errors:")
		for _, err := range errors {
			fmt.Fprintln(os.Stderr, err)
		}
		fmt.Printf("\nFound %d error(s)\n", len(errors))
		return true
	}

	// Count token types
	tokenCounts := make(map[string]int)
	for _, token := range tokens {
		tokenCounts[token.Type.String()]++
	}

	fmt.Println()
	fmt.Println("Tokens:")
	for _, token := range tokens {
		if token.Type == tokens.EOF {
			continue
		}
		fmt.Printf("  %-15s %-20s", token.Type, token.Lexeme)
		if token.Literal != nil {
			fmt.Printf(" = %v", token.Literal)
		}
		fmt.Println()
	}

	fmt.Println()
	fmt.Printf("Total tokens: %d\n", len(tokens)-1) // -1 for EOF
	fmt.Printf("Unique token types: %d\n", len(tokenCounts))
	fmt.Println()

	return false
}
```

---

### Task 4: Add Verbose Mode (30 minutes)

**Add a --verbose flag:**

Update `main()`:

```go
var verbose bool

func main() {
	// Check for flags
	args := os.Args[1:]
	for i, arg := range args {
		if arg == "-v" || arg == "--verbose" {
			verbose = true
			args = append(args[:i], args[i+1:]...)
			break
		}
	}

	if len(args) > 1 {
		fmt.Println("Usage: lox [-v|--verbose] [script]")
		os.Exit(64)
	} else if len(args) == 1 {
		runFile(args[0])
	} else {
		runPrompt()
	}
}
```

Use verbose mode to show additional information:

```go
if verbose {
	fmt.Printf("Scanning source: %d characters\n", len(source))
	fmt.Printf("Starting scan...\n\n")
}
```

---

### Task 5: Create Test Suite Script (45 minutes)

**Create `scripts/run-tests.sh`:**

```bash
#!/bin/bash

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo "================================="
echo "Konfiguru Lox Lexer Test Suite"
echo "================================="
echo ""

# Build first
echo "Building lexer..."
make build
if [ $? -ne 0 ]; then
    echo -e "${RED}Build failed!${NC}"
    exit 1
fi
echo -e "${GREEN}Build successful!${NC}"
echo ""

# Run Go tests
echo "Running Go unit tests..."
go test ./... -v
if [ $? -eq 0 ]; then
    echo -e "${GREEN}‚úì All Go tests passed!${NC}"
else
    echo -e "${RED}‚úó Some Go tests failed!${NC}"
    exit 1
fi
echo ""

# Test example files
echo "Testing example files..."
PASSED=0
FAILED=0

for file in examples/*.lox; do
    echo -n "Testing $(basename $file)... "
    ./lox "$file" > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}‚úì${NC}"
        PASSED=$((PASSED + 1))
    else
        echo -e "${RED}‚úó${NC}"
        FAILED=$((FAILED + 1))
    fi
done

echo ""
echo "Example files: $PASSED passed, $FAILED failed"
echo ""

if [ $FAILED -eq 0 ]; then
    echo -e "${GREEN}=================================${NC}"
    echo -e "${GREEN}All tests passed! üéâ${NC}"
    echo -e "${GREEN}=================================${NC}"
    exit 0
else
    echo -e "${RED}=================================${NC}"
    echo -e "${RED}Some tests failed${NC}"
    echo -e "${RED}=================================${NC}"
    exit 1
fi
```

Make it executable:
```bash
chmod +x scripts/run-tests.sh
```

---

### Task 6: Run Complete Test Suite (20 minutes)

**Run all tests:**
```bash
# Run the comprehensive test suite
./scripts/run-tests.sh

# Run with coverage
go test ./pkg/lexer -cover

# Generate coverage HTML
go test ./pkg/lexer -coverprofile=coverage.out
go tool cover -html=coverage.out -o coverage.html
```

**Verify:**
- All Go tests pass
- All example files scan correctly
- Coverage >85%
- No errors or warnings

---

### Task 7: Final Code Review and Commit (30 minutes)

**Review all code:**
- Check for TODO comments
- Ensure all functions have comments
- Verify error messages are helpful
- Clean up any debug code

**Run final checks:**
```bash
# Format all code
go fmt ./...

# Run linter (if available)
golangci-lint run

# Run all tests
./scripts/run-tests.sh
```

**Git commit:**
```bash
git add .
git commit -m "feat: final polish and production readiness

- Improve error messages with line/column context
- Add file statistics output
- Add verbose mode flag
- Create comprehensive test suite script
- Test with complex real-world Lox programs
- Add fibonacci, calculator, and objects examples
- Verify >85% test coverage

Day 20/30: Lexer production-ready with excellent UX"
```

---

## üìñ Resources

**Error Message Design:**
- [Writing Good Error Messages](https://wix-ux.com/when-life-gives-you-lemons-write-better-error-messages-46c5223e1a2f)
- [Compiler Error Messages](https://elm-lang.org/news/compiler-errors-for-humans)

---

## ‚úÖ End-of-Day Checklist

- [ ] Improved error messages with context
- [ ] Created complex example Lox files
- [ ] Added file statistics output
- [ ] Added verbose mode
- [ ] Created comprehensive test script
- [ ] All tests pass: `./scripts/run-tests.sh`
- [ ] Coverage >85%: `go test ./pkg/lexer -cover`
- [ ] Code formatted: `go fmt ./...`
- [ ] Code committed to git

**Time Spent:** ~4 hours (45+60+30+30+45+20+30 = 260 minutes)

---

## üîó Navigation

- [‚Üê Day 019: REPL Interactive Mode](Day-019.md)
- [‚Üí Day 021: Week 3 Review & Manual Testing](Day-021.md)
- [‚Üë Month Overview](README.md)

---

## üìù Learning Notes

**Production Readiness Checklist:**
- ‚úÖ Excellent error messages
- ‚úÖ Comprehensive test coverage
- ‚úÖ Real-world examples tested
- ‚úÖ User-friendly CLI
- ‚úÖ Good documentation
- ‚úÖ Clean, formatted code

**What Makes Good Error Messages:**
1. **Location**: Line and column number
2. **Context**: Show the offending line
3. **Pointer**: Visual indicator of error position
4. **Message**: Clear explanation of what's wrong
5. **Helpful**: Suggest how to fix it

**Quality Metrics:**
- Test coverage >85%
- All examples pass
- No compiler warnings
- Clean code format
- Helpful error messages

---

*Progress: Day 20/30 complete* ‚≠ê
*Week 3: Integration Testing & REPL Development*

**Excellent work! Your lexer is production-ready!**
