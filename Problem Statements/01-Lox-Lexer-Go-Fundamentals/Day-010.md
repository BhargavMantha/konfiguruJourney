# Day 010: Number Literal Scanning (Part 1)

**Month 1:** Lox Lexer & Go Fundamentals
**Phase:** Foundation
**Week:** 2 of 4 - Literals & Advanced Scanning

---

## ðŸŽ¯ Today's Goal

Implement number literal scanning in the Lox lexer. By the end of today, you'll have helper methods (`isDigit()`, `peekNext()`) and the foundation of `scanNumber()` to handle integer literals.

**What You'll Build:** Number scanning for integers, plus helper methods for lookahead.

---

## ðŸ“š What You'll Learn Today

**Go Fundamentals:**
- Character range checking (`c >= '0' && c <= '9'`)
- Lookahead with multiple positions
- Working with byte characters

**Compiler Concepts:**
- Digit detection algorithms
- Number token representation
- Lookahead for contextual scanning

**Crafting Interpreters:**
- Section 4.6 (Numbers) - Read first!

---

## âœ… Today's Tasks

### Task 1: Review Number Scanning Algorithm (25 minutes)

**What to do:**
Read Crafting Interpreters Section 4.6 (Numbers) and understand how numbers are scanned.

**Key concepts:**
1. Numbers start with a digit (0-9)
2. Consume all consecutive digits
3. Look for decimal point followed by more digits
4. Only create float if there's a digit after the decimal point
5. Store the numeric value (not string) in the token's literal

**Algorithm overview:**
```
when we see a digit:
  consume all digits
  if we see a '.' followed by a digit:
    consume the '.'
    consume all remaining digits
  parse the number string to float64
  add NUMBER token with parsed value
```

**Why lookahead matters:**
```lox
var x = 123.456;  // NUMBER (float)
var y = 123;      // NUMBER (integer, stored as float)
obj.method();     // DOT is an operator, NOT part of number
```

**Resources:**
- [Crafting Interpreters - Numbers](https://craftinginterpreters.com/scanning.html#literals)
- [Go strconv package](https://pkg.go.dev/strconv)

---

### Task 2: Implement isDigit() Helper (20 minutes)

**What to do:**
Add a helper function to check if a byte is a digit.

**Step-by-step:**

1. **Open scanner.go:**
```bash
cd /home/bhargav/Documents/Side-Projects/konfiguru
code pkg/lexer/scanner.go
```

2. **Add isDigit function:**

Add this helper function (it's a package-level function, not a method):

```go
// isDigit checks if a character is a digit (0-9)
func isDigit(c byte) bool {
	return c >= '0' && c <= '9'
}
```

**Why package-level?**
- This function doesn't need access to scanner state
- It's a pure utility function
- Can be reused by other functions

**Understanding the implementation:**
- `c >= '0'` checks if byte is at least '0' (ASCII 48)
- `c <= '9'` checks if byte is at most '9' (ASCII 57)
- Returns true only if byte is in range 0-9

3. **Verify compilation:**
```bash
go build ./pkg/lexer
```

---

### Task 3: Implement peekNext() Method (25 minutes)

**What to do:**
Add a method to look TWO characters ahead (current + 1).

**Why we need this:**
When we see `123.456`, we need to check:
1. Current character (`.`)
2. Next character (must be a digit like `4`)

Only if BOTH conditions are true do we consume the decimal point.

**Add peekNext method to Scanner:**

```go
// peekNext returns the character after current without consuming
// Used for two-character lookahead (e.g., decimal points in numbers)
func (s *Scanner) peekNext() byte {
	if s.current+1 >= len(s.source) {
		return 0 // Null byte if at end
	}
	return s.source[s.current+1]
}
```

**Understanding peekNext:**
- `s.current` is the current position
- `s.current+1` is one position ahead
- Check bounds first to avoid panic
- Return 0 (null byte) if past end of source

**Comparison with peek:**
```go
// peek() looks at s.current (next char to consume)
// peekNext() looks at s.current+1 (char after next)

Source: "123.456"
         ^
      current=3 (points to '.')

s.peek()     â†’ '.' (current position)
s.peekNext() â†’ '4' (one ahead)
```

**Verify compilation:**
```bash
go build ./pkg/lexer
```

---

### Task 4: Implement scanNumber() for Integers (40 minutes)

**What to do:**
Implement the `scanNumber()` method that handles integer literals (no decimals yet).

**Step-by-step:**

1. **Add scanNumber method:**

```go
// scanNumber scans a number literal (integer or float)
func (s *Scanner) scanNumber() {
	// Consume all leading digits
	for isDigit(s.peek()) {
		s.advance()
	}

	// For now, just handle integers
	// Tomorrow we'll add decimal point support

	// Get the number text
	text := s.source[s.start:s.current]

	// Parse to float64 (even integers are stored as float in Lox)
	value, err := strconv.ParseFloat(text, 64)
	if err != nil {
		s.addError(fmt.Sprintf("Invalid number: %s", text))
		return
	}

	s.addTokenLiteral(tokens.NUMBER, value)
}
```

**Key points:**
- Consume all consecutive digits with `for isDigit(s.peek())`
- Extract the number string: `s.source[s.start:s.current]`
- Parse with `strconv.ParseFloat(text, 64)`
- Store as float64 even for integers (Lox only has one number type)
- Report error if parsing fails

2. **Update scanToken() to call scanNumber:**

Find the `default` case in `scanToken()` and modify it:

```go
	default:
		if isDigit(c) {
			s.scanNumber()
		} else if isAlpha(c) {
			s.scanIdentifier()
		} else {
			s.addError("Unexpected character.")
		}
```

**What this does:**
- Check if character is a digit
- If yes, call `scanNumber()`
- Otherwise, check for identifier or report error

3. **Add import for strconv:**

At the top of scanner.go, update imports:

```go
import (
	"fmt"
	"strconv"

	"github.com/bhargav/konfiguru/pkg/tokens"
)
```

**Verify compilation:**
```bash
go build ./pkg/lexer
```

---

### Task 5: Write Tests for Integer Numbers (45 minutes)

**What to do:**
Write comprehensive tests for integer number scanning.

**Add tests to scanner_test.go:**

```go
func TestScanTokens_Numbers_Integers(t *testing.T) {
	tests := []struct {
		source      string
		wantLiteral float64
	}{
		{"0", 0.0},
		{"1", 1.0},
		{"123", 123.0},
		{"999", 999.0},
		{"42", 42.0},
	}

	for _, tt := range tests {
		scanner := NewScanner(tt.source)
		toks, errs := scanner.ScanTokens()

		if len(errs) != 0 {
			t.Errorf("source %q: unexpected errors %v", tt.source, errs)
			continue
		}

		if len(toks) != 2 { // NUMBER + EOF
			t.Fatalf("source %q: got %d tokens, want 2", tt.source, len(toks))
		}

		if toks[0].Type != tokens.NUMBER {
			t.Errorf("source %q: token type = %v, want NUMBER",
				tt.source, toks[0].Type)
		}

		if toks[0].Literal != tt.wantLiteral {
			t.Errorf("source %q: literal = %v, want %v",
				tt.source, toks[0].Literal, tt.wantLiteral)
		}

		// Verify lexeme matches source
		if toks[0].Lexeme != tt.source {
			t.Errorf("source %q: lexeme = %q, want %q",
				tt.source, toks[0].Lexeme, tt.source)
		}
	}
}

func TestScanTokens_Numbers_InExpressions(t *testing.T) {
	source := "1 + 2 - 3 * 4"
	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("unexpected errors: %v", errs)
	}

	expected := []struct {
		tokenType tokens.TokenType
		literal   interface{}
	}{
		{tokens.NUMBER, 1.0},
		{tokens.PLUS, nil},
		{tokens.NUMBER, 2.0},
		{tokens.MINUS, nil},
		{tokens.NUMBER, 3.0},
		{tokens.STAR, nil},
		{tokens.NUMBER, 4.0},
		{tokens.EOF, nil},
	}

	if len(toks) != len(expected) {
		t.Fatalf("got %d tokens, want %d", len(toks), len(expected))
	}

	for i, exp := range expected {
		if toks[i].Type != exp.tokenType {
			t.Errorf("token[%d] type = %v, want %v",
				i, toks[i].Type, exp.tokenType)
		}
		if exp.literal != nil && toks[i].Literal != exp.literal {
			t.Errorf("token[%d] literal = %v, want %v",
				i, toks[i].Literal, exp.literal)
		}
	}
}

func TestScanTokens_Numbers_WithVariables(t *testing.T) {
	source := "var x = 42;"
	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("unexpected errors: %v", errs)
	}

	expected := []tokens.TokenType{
		tokens.VAR,
		tokens.IDENTIFIER,
		tokens.EQUAL,
		tokens.NUMBER,
		tokens.SEMICOLON,
		tokens.EOF,
	}

	if len(toks) != len(expected) {
		t.Fatalf("got %d tokens, want %d", len(toks), len(expected))
	}

	for i, exp := range expected {
		if toks[i].Type != exp {
			t.Errorf("token[%d] type = %v, want %v", i, toks[i].Type, exp)
		}
	}

	// Verify the number literal
	if toks[3].Literal != 42.0 {
		t.Errorf("number literal = %v, want 42.0", toks[3].Literal)
	}
}
```

**Run the tests:**
```bash
go test ./pkg/lexer -v -run TestScanTokens_Numbers
```

Expected: All tests pass

---

### Task 6: Manual Testing in REPL (20 minutes)

**What to do:**
Test number scanning interactively.

**Build and run:**
```bash
make build
./lox
```

**Test integers:**
```
> 42
NUMBER 42 42
EOF  <nil>

> 0
NUMBER 0 0
EOF  <nil>

> 999
NUMBER 999 999
EOF  <nil>

> 1 + 2 * 3
NUMBER 1 1
PLUS + <nil>
NUMBER 2 2
STAR * <nil>
NUMBER 3 3
EOF  <nil>

> var count = 100;
VAR var <nil>
IDENTIFIER count <nil>
EQUAL = <nil>
NUMBER 100 100
SEMICOLON ; <nil>
EOF  <nil>

> exit
```

**What to verify:**
- Integers are scanned correctly
- Number tokens have correct literal values (as float64)
- Numbers work in arithmetic expressions
- Numbers work in variable assignments

---

## ðŸ“– Resources

**Essential:**
- [Crafting Interpreters - Numbers](https://craftinginterpreters.com/scanning.html#literals)
- [Go strconv.ParseFloat](https://pkg.go.dev/strconv#ParseFloat)
- [ASCII Table](https://www.asciitable.com/) - Understanding byte values

**Go Byte Handling:**
- In Go, `byte` is an alias for `uint8`
- ASCII digits '0'-'9' have values 48-57
- Character literals like '0' are byte constants

---

## âœ… End-of-Day Checklist

- [ ] Read Crafting Interpreters Section 4.6 (Numbers)
- [ ] Implemented `isDigit()` helper function
- [ ] Implemented `peekNext()` method
- [ ] Implemented `scanNumber()` for integers
- [ ] Updated `scanToken()` to handle digits
- [ ] Added strconv import
- [ ] Written integer number tests - all passing
- [ ] Tested in REPL manually
- [ ] All tests pass: `go test ./pkg/lexer -v`
- [ ] Code committed to git (see below)

**Git commit:**
```bash
git add pkg/lexer/
git commit -m "feat: implement integer number scanning

- Add isDigit() helper for digit detection
- Add peekNext() for two-character lookahead
- Implement scanNumber() for integer literals
- Parse numbers to float64 using strconv.ParseFloat
- Add comprehensive tests for integer numbers
- Verify numbers work in expressions

Day 10/30: Integer number scanning complete"
```

**Time Spent:** ~2.5 hours (25+20+25+40+45+20 = 175 minutes)

---

## ðŸ”— Navigation

- [â† Day 009: String Multiline & Error Handling](Day-009.md)
- [â†’ Day 011: Number Literals - Floats & Testing](Day-011.md)
- [â†‘ Month Overview](README.md)

---

## ðŸ“ Learning Notes

**Key Concepts Learned:**

1. **isDigit Implementation:**
   ```go
   func isDigit(c byte) bool {
       return c >= '0' && c <= '9'
   }
   ```
   - Simple range check using byte comparisons
   - ASCII values: '0' = 48, '9' = 57

2. **Lookahead Pattern:**
   - `peek()` looks at current (next to consume)
   - `peekNext()` looks one position ahead
   - Needed for contextual decisions (decimal points)

3. **Number Parsing:**
   - Use `strconv.ParseFloat(text, 64)`
   - Store as float64 (Lox's only number type)
   - Even integers like `42` â†’ `42.0`

4. **Scanning Pattern:**
   ```go
   // Consume all digits
   for isDigit(s.peek()) {
       s.advance()
   }
   // Extract and parse
   text := s.source[s.start:s.current]
   value, _ := strconv.ParseFloat(text, 64)
   ```

**Common Gotchas:**
- Don't forget to import `strconv`
- Remember numbers are stored as float64, not int
- Check bounds in `peekNext()` to avoid panic

**Tomorrow's Preview:**
You'll enhance number scanning to handle:
- Decimal points (`123.456`)
- Fractional numbers (`0.999`)
- Edge cases (`.123` is NOT valid, must be `0.123`)

---

*Progress: Day 10/30 complete* â­
*Week 2: String & Number Literals*

**Commit your daily notes to Obsidian!**
