# Day 013: Keywords vs Identifiers

**Month 1:** Lox Lexer & Go Fundamentals
**Phase:** Foundation
**Week:** 2 of 4 - Literals & Advanced Scanning

---

## üéØ Today's Goal

Verify keyword recognition works correctly and test the distinction between keywords and similar-looking identifiers. By the end of today, you'll have comprehensive tests ensuring all 15 Lox keywords are recognized properly.

**What You'll Build:** Complete keyword/identifier testing and validation.

---

## üìö What You'll Learn Today

**Go Fundamentals:**
- Map lookups and behavior
- Table-driven test patterns
- Subtest organization

**Compiler Concepts:**
- Reserved words vs identifiers
- Case sensitivity in languages
- Keyword lookup tables

---

## ‚úÖ Today's Tasks

### Task 1: Review Lox Keywords (15 minutes)

**All 15 Lox keywords:**

1. `and` - Logical AND operator
2. `class` - Class declaration
3. `else` - Else clause
4. `false` - Boolean false literal
5. `for` - For loop
6. `fun` - Function declaration
7. `if` - If statement
8. `nil` - Null/nil value
9. `or` - Logical OR operator
10. `print` - Print statement
11. `return` - Return statement
12. `super` - Superclass reference
13. `this` - Instance reference
14. `true` - Boolean true literal
15. `var` - Variable declaration
16. `while` - While loop

**Important:** Keywords are case-sensitive! `var` is a keyword, but `Var` and `VAR` are identifiers.

**Resources:**
- [Crafting Interpreters - Keywords](https://craftinginterpreters.com/scanning.html#identifiers-and-keywords)

---

### Task 2: Test All Keywords (45 minutes)

**Add comprehensive keyword tests to scanner_test.go:**

```go
func TestScanTokens_AllKeywords(t *testing.T) {
	tests := []struct {
		keyword   string
		tokenType tokens.TokenType
	}{
		{"and", tokens.AND},
		{"class", tokens.CLASS},
		{"else", tokens.ELSE},
		{"false", tokens.FALSE},
		{"for", tokens.FOR},
		{"fun", tokens.FUN},
		{"if", tokens.IF},
		{"nil", tokens.NIL},
		{"or", tokens.OR},
		{"print", tokens.PRINT},
		{"return", tokens.RETURN},
		{"super", tokens.SUPER},
		{"this", tokens.THIS},
		{"true", tokens.TRUE},
		{"var", tokens.VAR},
		{"while", tokens.WHILE},
	}

	for _, tt := range tests {
		t.Run(tt.keyword, func(t *testing.T) {
			scanner := NewScanner(tt.keyword)
			toks, errs := scanner.ScanTokens()

			if len(errs) != 0 {
				t.Fatalf("unexpected errors: %v", errs)
			}

			if len(toks) != 2 { // KEYWORD + EOF
				t.Fatalf("got %d tokens, want 2", len(toks))
			}

			if toks[0].Type != tt.tokenType {
				t.Errorf("token type = %v, want %v", toks[0].Type, tt.tokenType)
			}

			if toks[0].Lexeme != tt.keyword {
				t.Errorf("lexeme = %q, want %q", toks[0].Lexeme, tt.keyword)
			}
		})
	}
}
```

**Run the test:**
```bash
go test ./pkg/lexer -v -run TestScanTokens_AllKeywords
```

Expected: All 15 keywords pass

---

### Task 3: Test Keyword vs Identifier Edge Cases (40 minutes)

**Test similar-looking identifiers that are NOT keywords:**

```go
func TestScanTokens_KeywordsVsIdentifiers(t *testing.T) {
	tests := []struct {
		name       string
		source     string
		wantType   tokens.TokenType
		wantLexeme string
	}{
		// Keywords
		{"keyword var", "var", tokens.VAR, "var"},
		{"keyword if", "if", tokens.IF, "if"},
		{"keyword while", "while", tokens.WHILE, "while"},

		// Identifiers that look similar to keywords
		{"identifier variable", "variable", tokens.IDENTIFIER, "variable"},
		{"identifier varName", "varName", tokens.IDENTIFIER, "varName"},
		{"identifier ifTrue", "ifTrue", tokens.IDENTIFIER, "ifTrue"},
		{"identifier whileLoop", "whileLoop", tokens.IDENTIFIER, "whileLoop"},
		{"identifier and_", "and_", tokens.IDENTIFIER, "and_"},
		{"identifier _var", "_var", tokens.IDENTIFIER, "_var"},

		// Case sensitivity
		{"identifier Var", "Var", tokens.IDENTIFIER, "Var"},
		{"identifier VAR", "VAR", tokens.IDENTIFIER, "VAR"},
		{"identifier If", "If", tokens.IDENTIFIER, "If"},
		{"identifier While", "While", tokens.IDENTIFIER, "While"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			scanner := NewScanner(tt.source)
			toks, errs := scanner.ScanTokens()

			if len(errs) != 0 {
				t.Fatalf("unexpected errors: %v", errs)
			}

			if len(toks) != 2 {
				t.Fatalf("got %d tokens, want 2", len(toks))
			}

			if toks[0].Type != tt.wantType {
				t.Errorf("token type = %v, want %v", toks[0].Type, tt.wantType)
			}

			if toks[0].Lexeme != tt.wantLexeme {
				t.Errorf("lexeme = %q, want %q", toks[0].Lexeme, tt.wantLexeme)
			}
		})
	}
}
```

**Run:**
```bash
go test ./pkg/lexer -v -run TestScanTokens_KeywordsVsIdentifiers
```

---

### Task 4: Test Keywords in Real Code (35 minutes)

**Test keywords in realistic Lox programs:**

```go
func TestScanTokens_KeywordsInProgram(t *testing.T) {
	source := `var x = 10;
if (x > 5) {
    print "large";
} else {
    print "small";
}`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("unexpected errors: %v", errs)
	}

	// Verify we have the expected keywords
	keywordCounts := make(map[tokens.TokenType]int)
	for _, tok := range toks {
		keywordCounts[tok.Type]++
	}

	expectedKeywords := map[tokens.TokenType]int{
		tokens.VAR:   1,
		tokens.IF:    1,
		tokens.PRINT: 2,
		tokens.ELSE:  1,
	}

	for keyword, expectedCount := range expectedKeywords {
		if keywordCounts[keyword] != expectedCount {
			t.Errorf("keyword %v: got %d occurrences, want %d",
				keyword, keywordCounts[keyword], expectedCount)
		}
	}
}

func TestScanTokens_FunctionWithKeywords(t *testing.T) {
	source := `fun greet(name) {
    print "Hello, " + name;
    return true;
}`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("unexpected errors: %v", errs)
	}

	// Find all keywords in order
	var keywordTypes []tokens.TokenType
	for _, tok := range toks {
		switch tok.Type {
		case tokens.FUN, tokens.PRINT, tokens.RETURN, tokens.TRUE:
			keywordTypes = append(keywordTypes, tok.Type)
		}
	}

	expected := []tokens.TokenType{
		tokens.FUN,
		tokens.PRINT,
		tokens.RETURN,
		tokens.TRUE,
	}

	if len(keywordTypes) != len(expected) {
		t.Fatalf("got %d keywords, want %d", len(keywordTypes), len(expected))
	}

	for i, exp := range expected {
		if keywordTypes[i] != exp {
			t.Errorf("keyword[%d] = %v, want %v", i, keywordTypes[i], exp)
		}
	}
}

func TestScanTokens_LogicalOperators(t *testing.T) {
	source := "true and false or nil"
	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("unexpected errors: %v", errs)
	}

	expected := []tokens.TokenType{
		tokens.TRUE,
		tokens.AND,
		tokens.FALSE,
		tokens.OR,
		tokens.NIL,
		tokens.EOF,
	}

	if len(toks) != len(expected) {
		t.Fatalf("got %d tokens, want %d", len(toks), len(expected))
	}

	for i, exp := range expected {
		if toks[i].Type != exp {
			t.Errorf("token[%d] = %v, want %v", i, toks[i].Type, exp)
		}
	}
}
```

**Run:**
```bash
go test ./pkg/lexer -v -run TestScanTokens_.*Keywords
go test ./pkg/lexer -v -run TestScanTokens_Function
go test ./pkg/lexer -v -run TestScanTokens_Logical
```

---

### Task 5: Manual REPL Testing (20 minutes)

**Test keywords interactively:**

```bash
make build
./lox
```

**Test all keywords:**
```
> var x = 10;
VAR var <nil>
IDENTIFIER x <nil>
EQUAL = <nil>
NUMBER 10 10
SEMICOLON ; <nil>
EOF  <nil>

> if (true) print "yes";
IF if <nil>
LEFT_PAREN ( <nil>
TRUE true <nil>
RIGHT_PAREN ) <nil>
PRINT print <nil>
STRING "yes" yes
SEMICOLON ; <nil>
EOF  <nil>

> for (var i = 0; i < 10; i = i + 1) print i;
FOR for <nil>
(... should see all tokens ...)

> fun greet() { return "hello"; }
FUN fun <nil>
(... should see all tokens ...)

> class Point { }
CLASS class <nil>
IDENTIFIER Point <nil>
LEFT_BRACE { <nil>
RIGHT_BRACE } <nil>
EOF  <nil>

> variable
IDENTIFIER variable <nil>
EOF  <nil>

> Var
IDENTIFIER Var <nil>
EOF  <nil>

> exit
```

**Verify:**
- All keywords are recognized
- Similar identifiers work (variable, Var, VAR)
- Keywords work in context (if statements, functions, etc.)

---

### Task 6: Run Full Test Suite (15 minutes)

**Run all lexer tests:**
```bash
go test ./pkg/lexer -v
```

**Verify:**
- All tests passing
- Good coverage of keywords
- No regressions

**If failures occur:**
1. Check `tokens.Keywords` map in tokens/token.go
2. Verify all 15 keywords are in the map
3. Check case sensitivity (keywords are lowercase)
4. Ensure `LookupIdent()` returns IDENTIFIER for unknowns

---

## üìñ Resources

**Essential:**
- [Crafting Interpreters - Keywords](https://craftinginterpreters.com/scanning.html#identifiers-and-keywords)
- [Go Maps](https://go.dev/blog/maps)

**Keyword Design:**
- Most languages use lowercase keywords
- Some use UPPERCASE (SQL)
- Some allow both (SQL again)
- Lox: lowercase only

---

## ‚úÖ End-of-Day Checklist

- [ ] Tested all 15 Lox keywords - all passing
- [ ] Tested keyword vs identifier edge cases
- [ ] Tested keywords in real Lox code
- [ ] Tested case sensitivity (Var vs var)
- [ ] Tested keywords in REPL
- [ ] All tests pass: `go test ./pkg/lexer -v`
- [ ] Code committed to git (see below)

**Git commit:**
```bash
git add pkg/lexer/
git commit -m "test: comprehensive keyword vs identifier tests

- Test all 15 Lox keywords individually
- Test keywords vs similar identifiers (variable, Var, VAR)
- Test keywords in realistic Lox programs
- Verify case sensitivity (keywords are lowercase)
- Test logical operators (and, or)
- Verify functions, classes, control flow keywords

Day 13/30: Keyword testing complete"
```

**Time Spent:** ~2.5 hours (15+45+40+35+20+15 = 170 minutes)

---

## üîó Navigation

- [‚Üê Day 012: Identifier Scanning](Day-012.md)
- [‚Üí Day 014: Week 2 Integration Testing & Review](Day-014.md)
- [‚Üë Month Overview](README.md)

---

## üìù Learning Notes

**Key Concepts:**

1. **Keyword Lookup:**
   ```go
   // In tokens/token.go
   var Keywords = map[string]TokenType{
       "and": AND,
       "var": VAR,
       // ... etc
   }

   func LookupIdent(ident string) TokenType {
       if tok, ok := Keywords[ident]; ok {
           return tok  // It's a keyword
       }
       return IDENTIFIER  // It's an identifier
   }
   ```

2. **Case Sensitivity:**
   - `var` ‚Üí VAR (keyword)
   - `Var` ‚Üí IDENTIFIER
   - `VAR` ‚Üí IDENTIFIER
   - `variable` ‚Üí IDENTIFIER

3. **Keyword vs Identifier:**
   - Scan as identifier first
   - Then check keyword map
   - Simple and efficient

4. **Testing Strategy:**
   - Test each keyword individually
   - Test edge cases (similar identifiers)
   - Test in realistic programs
   - Verify no false positives

**Tomorrow's Preview:**
Week 2 integration testing and review:
- Test complete expressions
- Verify all Week 2 features work together
- Review progress
- Plan Week 3

---

*Progress: Day 13/30 complete* ‚≠ê
*Week 2: String & Number Literals*

**Commit your daily notes to Obsidian!**
