# Day 016: Integration Tests - Complex Programs

**Month 1:** Lox Lexer & Go Fundamentals
**Phase:** Foundation
**Week:** 3 of 4 - Integration Testing & REPL Development

---

## üéØ Today's Goal

Extend the integration test suite to cover complex Lox programs: if/else statements, function declarations, loops, and classes. Ensure the lexer correctly handles all Lox language constructs.

**What You'll Build:** Additional integration tests for control flow, functions, loops, and classes.

---

## üìö What You'll Learn Today

**Go Fundamentals:**
- Advanced table-driven test patterns
- Testing complex nested structures
- Keyword and token counting techniques

**Compiler Concepts:**
- Control flow statement tokenization
- Function declaration scanning
- Loop construct recognition
- Class definition handling

---

## ‚úÖ Today's Tasks

### Task 1: Test If/Else Statements (45 minutes)

**What to do:**
Add comprehensive tests for conditional statements.

**Add to `pkg/lexer/integration_test.go`:**

```go
func TestScanTokens_IfStatement(t *testing.T) {
	source := `if (x > 5) {
    print "large";
} else {
    print "small";
}`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("got errors: %v", errs)
	}

	expected := []tokens.TokenType{
		tokens.IF, tokens.LEFT_PAREN, tokens.IDENTIFIER, tokens.GREATER, tokens.NUMBER,
		tokens.RIGHT_PAREN, tokens.LEFT_BRACE,
		tokens.PRINT, tokens.STRING, tokens.SEMICOLON,
		tokens.RIGHT_BRACE, tokens.ELSE, tokens.LEFT_BRACE,
		tokens.PRINT, tokens.STRING, tokens.SEMICOLON,
		tokens.RIGHT_BRACE,
		tokens.EOF,
	}

	if len(toks) != len(expected) {
		t.Fatalf("got %d tokens, want %d", len(toks), len(expected))
	}

	for i, exp := range expected {
		if toks[i].Type != exp {
			t.Errorf("token[%d] = %v, want %v", i, toks[i].Type, exp)
		}
	}
}

func TestScanTokens_NestedIfElse(t *testing.T) {
	source := `if (x > 0) {
    if (x > 10) {
        print "large";
    } else {
        print "medium";
    }
} else {
    print "small or negative";
}`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("got errors: %v", errs)
	}

	// Count IF and ELSE keywords
	ifCount := 0
	elseCount := 0
	for _, tok := range toks {
		if tok.Type == tokens.IF {
			ifCount++
		}
		if tok.Type == tokens.ELSE {
			elseCount++
		}
	}

	if ifCount != 2 {
		t.Errorf("got %d IF keywords, want 2", ifCount)
	}
	if elseCount != 2 {
		t.Errorf("got %d ELSE keywords, want 2", elseCount)
	}
}

func TestScanTokens_IfWithComplexCondition(t *testing.T) {
	source := `if (x > 5 and y < 10 or z == 0) {
    print "complex condition";
}`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("got errors: %v", errs)
	}

	// Verify logical operators
	hasAnd := false
	hasOr := false
	for _, tok := range toks {
		if tok.Type == tokens.AND {
			hasAnd = true
		}
		if tok.Type == tokens.OR {
			hasOr = true
		}
	}

	if !hasAnd || !hasOr {
		t.Error("missing expected logical operators (and/or)")
	}
}
```

**Run:**
```bash
go test ./pkg/lexer -v -run TestScanTokens_If
```

---

### Task 2: Test Function Declarations (45 minutes)

**What to do:**
Test function definitions with parameters and return statements.

**Add to `pkg/lexer/integration_test.go`:**

```go
func TestScanTokens_FunctionDeclaration(t *testing.T) {
	source := `fun add(a, b) {
    return a + b;
}`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("got errors: %v", errs)
	}

	expected := []tokens.TokenType{
		tokens.FUN, tokens.IDENTIFIER, tokens.LEFT_PAREN, tokens.IDENTIFIER,
		tokens.COMMA, tokens.IDENTIFIER, tokens.RIGHT_PAREN, tokens.LEFT_BRACE,
		tokens.RETURN, tokens.IDENTIFIER, tokens.PLUS, tokens.IDENTIFIER,
		tokens.SEMICOLON, tokens.RIGHT_BRACE,
		tokens.EOF,
	}

	if len(toks) != len(expected) {
		t.Fatalf("got %d tokens, want %d", len(toks), len(expected))
	}

	for i, exp := range expected {
		if toks[i].Type != exp {
			t.Errorf("token[%d] = %v, want %v", i, toks[i].Type, exp)
		}
	}
}

func TestScanTokens_FunctionWithNoParams(t *testing.T) {
	source := `fun greet() {
    print "Hello, World!";
}`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("got errors: %v", errs)
	}

	// Verify FUN keyword and parentheses
	hasFun := false
	parenPairs := 0
	for _, tok := range toks {
		if tok.Type == tokens.FUN {
			hasFun = true
		}
		if tok.Type == tokens.LEFT_PAREN {
			parenPairs++
		}
	}

	if !hasFun {
		t.Error("missing FUN keyword")
	}
	if parenPairs < 1 {
		t.Error("missing parentheses for function declaration")
	}
}

func TestScanTokens_FunctionCallWithArgs(t *testing.T) {
	source := `var result = add(5, 3);
print result;`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("got errors: %v", errs)
	}

	// Count numbers and commas
	numberCount := 0
	commaCount := 0
	for _, tok := range toks {
		if tok.Type == tokens.NUMBER {
			numberCount++
		}
		if tok.Type == tokens.COMMA {
			commaCount++
		}
	}

	if numberCount != 2 {
		t.Errorf("got %d numbers, want 2", numberCount)
	}
	if commaCount != 1 {
		t.Errorf("got %d commas, want 1", commaCount)
	}
}
```

**Run:**
```bash
go test ./pkg/lexer -v -run TestScanTokens_Function
```

---

### Task 3: Test Loop Constructs (45 minutes)

**What to do:**
Add tests for `for` and `while` loops.

**Add to `pkg/lexer/integration_test.go`:**

```go
func TestScanTokens_ForLoop(t *testing.T) {
	source := `for (var i = 0; i < 10; i = i + 1) {
    print i;
}`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("got errors: %v", errs)
	}

	// Count key tokens
	counts := make(map[tokens.TokenType]int)
	for _, tok := range toks {
		counts[tok.Type]++
	}

	if counts[tokens.FOR] != 1 {
		t.Errorf("got %d FOR keywords, want 1", counts[tokens.FOR])
	}
	if counts[tokens.VAR] != 1 {
		t.Errorf("got %d VAR keywords, want 1", counts[tokens.VAR])
	}
	if counts[tokens.SEMICOLON] != 3 {
		t.Errorf("got %d semicolons, want 3", counts[tokens.SEMICOLON])
	}
}

func TestScanTokens_WhileLoop(t *testing.T) {
	source := `var count = 0;
while (count < 5) {
    print count;
    count = count + 1;
}`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("got errors: %v", errs)
	}

	// Verify WHILE keyword
	hasWhile := false
	for _, tok := range toks {
		if tok.Type == tokens.WHILE {
			hasWhile = true
			break
		}
	}

	if !hasWhile {
		t.Error("missing WHILE keyword")
	}
}

func TestScanTokens_NestedLoops(t *testing.T) {
	source := `for (var i = 0; i < 3; i = i + 1) {
    for (var j = 0; j < 3; j = j + 1) {
        print i * j;
    }
}`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("got errors: %v", errs)
	}

	// Count FOR keywords
	forCount := 0
	for _, tok := range toks {
		if tok.Type == tokens.FOR {
			forCount++
		}
	}

	if forCount != 2 {
		t.Errorf("got %d FOR keywords, want 2 (nested loops)", forCount)
	}
}
```

**Run:**
```bash
go test ./pkg/lexer -v -run TestScanTokens_.*Loop
```

---

### Task 4: Test Class Definitions (45 minutes)

**What to do:**
Test class declarations with methods.

**Add to `pkg/lexer/integration_test.go`:**

```go
func TestScanTokens_ClassDeclaration(t *testing.T) {
	source := `class Point {
    fun init(x, y) {
        this.x = x;
        this.y = y;
    }

    fun distance() {
        return this.x * this.x + this.y * this.y;
    }
}

var p = Point();`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("got errors: %v", errs)
	}

	// Check for key keywords
	keywordCounts := make(map[tokens.TokenType]int)
	for _, tok := range toks {
		keywordCounts[tok.Type]++
	}

	if keywordCounts[tokens.CLASS] != 1 {
		t.Error("missing CLASS keyword")
	}
	if keywordCounts[tokens.THIS] < 3 {
		t.Errorf("got %d THIS keywords, want at least 3", keywordCounts[tokens.THIS])
	}
	if keywordCounts[tokens.FUN] < 2 {
		t.Errorf("got %d FUN keywords, want at least 2", keywordCounts[tokens.FUN])
	}
}

func TestScanTokens_ClassInheritance(t *testing.T) {
	source := `class Dog {
    fun bark() {
        print "woof";
    }
}

class Puppy {
    fun whimper() {
        print "whine";
    }
}`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	if len(errs) != 0 {
		t.Fatalf("got errors: %v", errs)
	}

	// Count CLASS keywords
	classCount := 0
	for _, tok := range toks {
		if tok.Type == tokens.CLASS {
			classCount++
		}
	}

	if classCount != 2 {
		t.Errorf("got %d CLASS keywords, want 2", classCount)
	}
}
```

**Run:**
```bash
go test ./pkg/lexer -v -run TestScanTokens_Class
```

---

### Task 5: Test Error Scenarios (30 minutes)

**What to do:**
Add tests for error handling in complex programs.

**Add to `pkg/lexer/integration_test.go`:**

```go
func TestScanTokens_WithErrors(t *testing.T) {
	source := `var x = "unterminated string
var y @ 5;`

	scanner := NewScanner(source)
	_, errs := scanner.ScanTokens()

	// Should have at least 2 errors: unterminated string and @ character
	if len(errs) < 2 {
		t.Errorf("got %d errors, want at least 2", len(errs))
	}
}

func TestScanTokens_MultipleErrorRecovery(t *testing.T) {
	source := `var x = "unterminated;
var y = 5 @ 3;
var z # invalid;`

	scanner := NewScanner(source)
	toks, errs := scanner.ScanTokens()

	// Should have multiple errors but still produce some valid tokens
	if len(errs) == 0 {
		t.Error("expected errors for invalid syntax")
	}

	// Should still scan some valid tokens
	if len(toks) < 3 {
		t.Error("scanner should recover and continue after errors")
	}
}
```

**Run:**
```bash
go test ./pkg/lexer -v -run TestScanTokens_.*Error
```

---

### Task 6: Run All Integration Tests (20 minutes)

**Run complete test suite:**
```bash
# Run all integration tests
go test ./pkg/lexer -v

# With coverage report
go test ./pkg/lexer -cover

# Generate detailed coverage
go test ./pkg/lexer -coverprofile=coverage.out
go tool cover -html=coverage.out
```

**Verify:**
- All tests passing (including yesterday's tests)
- Good coverage (should be >85%)
- No compilation errors

---

### Task 7: Commit Complex Integration Tests (10 minutes)

**Git commit:**
```bash
git add pkg/lexer/integration_test.go
git commit -m "test: add integration tests for complex Lox constructs

- Test if/else statements (including nested conditions)
- Test function declarations and calls
- Test for and while loops (including nested loops)
- Test class declarations with methods
- Test error recovery in complex programs
- Verify all Lox language features are correctly tokenized

Maps to Task 10 (Integration Test Suite), Steps 3-4

Day 16/30: Complex program testing complete"
```

---

## üìñ Resources

**Testing Patterns:**
- [Advanced Go Testing](https://quii.gitbook.io/learn-go-with-tests/)
- [Testing Complex Scenarios](https://go.dev/blog/subtests)

**Crafting Interpreters:**
- [Chapter 4 - Scanning](https://craftinginterpreters.com/scanning.html)

---

## ‚úÖ End-of-Day Checklist

- [ ] Wrote tests for if/else statements
- [ ] Wrote tests for function declarations
- [ ] Wrote tests for loop constructs
- [ ] Wrote tests for class definitions
- [ ] Wrote tests for error handling
- [ ] All tests passing: `go test ./pkg/lexer -v`
- [ ] Coverage >85%: `go test ./pkg/lexer -cover`
- [ ] Code committed to git
- [ ] Updated Obsidian notes

**Time Spent:** ~3 hours (45+45+45+45+30+20+10 = 240 minutes)

---

## üîó Navigation

- [‚Üê Day 015: Integration Test Suite (Part 1)](Day-015.md)
- [‚Üí Day 017: Error Testing & Edge Cases](Day-017.md)
- [‚Üë Month Overview](README.md)

---

## üìù Learning Notes

**What We Tested Today:**

1. **Control Flow:**
   - If/else statements
   - Nested conditionals
   - Complex logical conditions

2. **Functions:**
   - Function declarations with parameters
   - Functions with no parameters
   - Function calls with arguments
   - Return statements

3. **Loops:**
   - For loops with initialization, condition, increment
   - While loops
   - Nested loops

4. **Classes:**
   - Class declarations
   - Methods (functions inside classes)
   - Use of `this` keyword
   - Multiple classes in one program

5. **Error Handling:**
   - Unterminated strings in complex programs
   - Invalid characters
   - Error recovery (scanner continues after errors)

**Key Testing Insights:**
- Complex programs reveal integration issues that unit tests miss
- Token counting is useful for verifying program structure
- Error recovery is crucial - one error shouldn't stop entire scan
- Real-world Lox programs validate lexer completeness

**Tomorrow Preview:**
Error testing and edge cases - ensuring the lexer handles all possible inputs gracefully.

---

*Progress: Day 16/30 complete* ‚≠ê
*Week 3: Integration Testing & REPL Development*

**Excellent! Your lexer can now handle complete Lox programs!**
