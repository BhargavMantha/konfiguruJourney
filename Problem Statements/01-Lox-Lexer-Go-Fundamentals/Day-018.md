# Day 018: CLI REPL (Part 1) - Main Structure

**Month 1:** Lox Lexer & Go Fundamentals
**Phase:** Foundation
**Week:** 3 of 4 - Integration Testing & REPL Development

---

## üéØ Today's Goal

Create the main CLI structure for the Lox interpreter with REPL (Read-Eval-Print Loop) support. Implement file scanning and interactive mode.

**What You'll Build:** `cmd/lox/main.go` with `runFile()` and `runPrompt()` functions.

---

## üìö What You'll Learn Today

**Go Fundamentals:**
- Command-line argument handling (`os.Args`)
- File I/O (`os.ReadFile`)
- User input with `bufio.Reader`
- Exit codes and error handling

**REPL Concepts:**
- Interactive interpreters
- Read-eval-print loops
- User experience design

---

## ‚úÖ Today's Tasks

### Task 1: Create Main Entry Point (30 minutes)

**Create file: `cmd/lox/main.go`:**

```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strings"

	"github.com/bhargav/konfiguru/pkg/lexer"
)

func main() {
	if len(os.Args) > 2 {
		fmt.Println("Usage: lox [script]")
		os.Exit(64) // EX_USAGE from sysexits.h
	} else if len(os.Args) == 2 {
		runFile(os.Args[1])
	} else {
		runPrompt()
	}
}
```

**What this does:**
- No arguments: Start interactive REPL
- One argument: Run Lox file
- More than one: Show usage and exit

**Standard exit codes:**
- `64`: Command line usage error
- `65`: Data format error (we'll use for Lox syntax errors)
- `74`: I/O error

---

### Task 2: Implement File Scanning (45 minutes)

**Add to `cmd/lox/main.go`:**

```go
func runFile(path string) {
	bytes, err := os.ReadFile(path)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading file: %v\n", err)
		os.Exit(74) // EX_IOERR
	}

	hadError := run(string(bytes))
	if hadError {
		os.Exit(65) // EX_DATAERR
	}
}

func run(source string) bool {
	scanner := lexer.NewScanner(source)
	tokens, errors := scanner.ScanTokens()

	// Print errors if any
	if len(errors) > 0 {
		for _, err := range errors {
			fmt.Fprintln(os.Stderr, err)
		}
		return true // Had error
	}

	// Print all tokens
	for _, token := range tokens {
		fmt.Println(token)
	}

	return false // No error
}
```

**Test file scanning:**
Create `examples/test.lox`:
```lox
var x = 10;
var y = 20;
var result = x + y;
print result;
```

Build and test:
```bash
go build -o lox ./cmd/lox
./lox examples/test.lox
```

Expected: All tokens printed, no errors

---

### Task 3: Implement Interactive REPL (60 minutes)

**Add to `cmd/lox/main.go`:**

```go
func runPrompt() {
	reader := bufio.NewReader(os.Stdin)

	fmt.Println("Lox REPL (Lexer only - Month 1)")
	fmt.Println("Type 'exit' or 'quit' to exit")
	fmt.Println()

	for {
		fmt.Print("> ")
		line, err := reader.ReadString('\n')
		if err != nil {
			// EOF or error - exit gracefully
			fmt.Println()
			break
		}

		line = strings.TrimSpace(line)

		// Check for exit commands
		if line == "exit" || line == "quit" {
			break
		}

		// Skip empty lines
		if line == "" {
			continue
		}

		// Run the line (don't exit on error in REPL mode)
		run(line)
	}
}
```

**Test the REPL:**
```bash
./lox
```

Try these commands:
```
> var x = 5;
> print "hello";
> 1 + 2 * 3
> exit
```

Each command should show the tokens generated.

---

### Task 4: Add REPL Help Command (30 minutes)

**Enhance the REPL with a help command:**

```go
func runPrompt() {
	reader := bufio.NewReader(os.Stdin)

	printWelcome()

	for {
		fmt.Print("> ")
		line, err := reader.ReadString('\n')
		if err != nil {
			fmt.Println()
			break
		}

		line = strings.TrimSpace(line)

		// Handle special commands
		if line == "exit" || line == "quit" {
			break
		}

		if line == "help" {
			printHelp()
			continue
		}

		if line == "clear" {
			clearScreen()
			continue
		}

		if line == "" {
			continue
		}

		run(line)
	}
}

func printWelcome() {
	fmt.Println("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
	fmt.Println("‚ïë   Lox Lexer REPL - Month 1 Project    ‚ïë")
	fmt.Println("‚ïë   Learning Compiler Fundamentals       ‚ïë")
	fmt.Println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
	fmt.Println()
	fmt.Println("Type 'help' for commands, 'exit' to quit")
	fmt.Println()
}

func printHelp() {
	fmt.Println()
	fmt.Println("Available commands:")
	fmt.Println("  help   - Show this help message")
	fmt.Println("  clear  - Clear the screen")
	fmt.Println("  exit   - Exit the REPL")
	fmt.Println("  quit   - Exit the REPL")
	fmt.Println()
	fmt.Println("Enter any Lox expression to see its tokens:")
	fmt.Println("  Examples:")
	fmt.Println("    var x = 5;")
	fmt.Println("    print \"hello\";")
	fmt.Println("    1 + 2 * 3")
	fmt.Println()
}

func clearScreen() {
	// Simple cross-platform clear (just print newlines)
	fmt.Print("\033[2J\033[H")
	printWelcome()
}
```

**Test the enhanced REPL:**
```bash
./lox
> help
> var x = 5;
> clear
> exit
```

---

### Task 5: Improve Token Output Formatting (30 minutes)

**Make token output more readable:**

Modify the `run()` function:

```go
func run(source string) bool {
	scanner := lexer.NewScanner(source)
	tokens, errors := scanner.ScanTokens()

	// Print errors if any
	if len(errors) > 0 {
		fmt.Println()
		fmt.Println("Errors:")
		for _, err := range errors {
			fmt.Fprintf(os.Stderr, "  %s\n", err)
		}
		fmt.Println()
		return true
	}

	// Print tokens in a formatted way
	fmt.Println()
	fmt.Println("Tokens:")
	for _, token := range tokens {
		// Skip EOF in interactive mode for cleaner output
		if token.Type == tokens.EOF {
			continue
		}
		fmt.Printf("  %-15s %-20s", token.Type, token.Lexeme)
		if token.Literal != nil {
			fmt.Printf(" = %v", token.Literal)
		}
		fmt.Println()
	}
	fmt.Println()

	return false
}
```

Now the output is much more readable!

---

### Task 6: Test with Example Programs (20 minutes)

**Create more example files:**

**`examples/variables.lox`:**
```lox
var name = "Alice";
var age = 25;
var pi = 3.14159;
print name;
print age;
print pi;
```

**`examples/expressions.lox`:**
```lox
var x = 10 + 5 * 2;
var y = (10 + 5) * 2;
var z = x > y;
print x;
print y;
print z;
```

**`examples/functions.lox`:**
```lox
fun greet(name) {
    print "Hello, " + name;
}

greet("World");
```

**Test all examples:**
```bash
./lox examples/variables.lox
./lox examples/expressions.lox
./lox examples/functions.lox
```

Verify all tokens are correct!

---

### Task 7: Update Makefile and Commit (15 minutes)

**Update `Makefile`:**
```makefile
.PHONY: build test run clean install

build:
	go build -o lox ./cmd/lox

test:
	go test -v ./...

run:
	go run ./cmd/lox

install:
	go install ./cmd/lox

clean:
	rm -f lox
	go clean

repl: build
	./lox

# Run a specific example
run-example:
	@if [ -z "$(FILE)" ]; then \
		echo "Usage: make run-example FILE=examples/test.lox"; \
	else \
		./lox $(FILE); \
	fi
```

**Test Makefile:**
```bash
make build
make repl
make run-example FILE=examples/variables.lox
```

**Git commit:**
```bash
git add cmd/lox/main.go examples/ Makefile
git commit -m "feat: add CLI REPL with file and interactive modes

- Implement main entry point with command-line arg handling
- Add runFile() for scanning Lox files
- Add runPrompt() for interactive REPL
- Implement REPL commands (help, clear, exit, quit)
- Improve token output formatting
- Add multiple example Lox files
- Update Makefile with REPL shortcuts

Maps to Task 11 (CLI REPL), Steps 1-3

Day 18/30: CLI REPL foundation complete"
```

---

## üìñ Resources

**Go CLI Development:**
- [Go Command-Line Apps](https://gobyexample.com/command-line-arguments)
- [bufio.Reader Documentation](https://pkg.go.dev/bufio#Reader)

**REPL Design:**
- [Crafting Interpreters - REPL](https://craftinginterpreters.com/a-map-of-the-territory.html#the-road-map)

---

## ‚úÖ End-of-Day Checklist

- [ ] Created `cmd/lox/main.go` with main entry point
- [ ] Implemented `runFile()` for file scanning
- [ ] Implemented `runPrompt()` for interactive REPL
- [ ] Added REPL commands (help, clear, exit)
- [ ] Improved token output formatting
- [ ] Created example Lox files
- [ ] Updated Makefile
- [ ] REPL works: `make repl`
- [ ] File scanning works: `./lox examples/test.lox`
- [ ] Code committed to git

**Time Spent:** ~3 hours (30+45+60+30+30+20+15 = 230 minutes)

---

## üîó Navigation

- [‚Üê Day 017: Error Testing & Edge Cases](Day-017.md)
- [‚Üí Day 019: REPL Interactive Mode](Day-019.md)
- [‚Üë Month Overview](README.md)

---

## üìù Learning Notes

**REPL Design Principles:**

1. **Immediate Feedback:**
   - Show results instantly
   - Clear, readable output
   - Helpful error messages

2. **User-Friendly:**
   - Simple commands (help, exit, clear)
   - Forgiving (handles empty input)
   - Good error recovery

3. **Cross-Platform:**
   - Works on Linux, Mac, Windows
   - Standard input/output
   - Portable Go code

**CLI Best Practices:**
- Use standard exit codes
- Print errors to stderr
- Print results to stdout
- Handle EOF gracefully
- Provide usage help

**What We Built:**
- ‚úÖ File-based Lox scanning
- ‚úÖ Interactive REPL
- ‚úÖ Formatted token output
- ‚úÖ Help system
- ‚úÖ Multiple example programs

**Tomorrow Preview:**
REPL testing and improvements - making the interactive experience even better.

---

*Progress: Day 18/30 complete* ‚≠ê
*Week 3: Integration Testing & REPL Development*

**Excellent! You now have a working Lox lexer with both file and interactive modes!**
